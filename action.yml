# Malnati/git-report-ops@v2.0.2
name: "Git Pull Request Ops"
description: "Engine de auditoria que assina o conte√∫do, detecta renames e envia notifica√ß√µes padronizadas para Pull Requests."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  pr_number:
    description: "N√∫mero da Pull Request origem, se ser√° usada para descobrir qual √© a branch destino da nova PR."
    required: true
  attached_file_path:
    description: "Arquivo anexo ao reposit√≥rio. (report.csv)"
    required: true
  branch_convention_prefix:
    required: false
    default: "ops/files"
  pr_title:
    required: false
    default: "üõ°Ô∏è Automated Pull Request"
  pr_template_path:
    required: true
    description: "Arquivo anexo ao reposit√≥rio. (pr-template.md)"
  timeline_template_path:
    required: true
    description: "Arquivo anexo ao reposit√≥rio. (timeline-template.md)"
  bot_name:
    description: "Nome do bot usado nos commits."
    required: false
    default: "git-pr-ops-bot"
  bot_email:
    required: false
    default: "git-pr-ops@users.noreply.github.com"
  errors:
    required: false
    default: ".github/workflows/errors.log"

runs:
  using: "composite"
  steps:
    - id: step_validate_inputs
      name: "üîß Setup & Input Validation"
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        CALLER_ID: ${{ inputs.caller_id }}
        BRANCH_CONVENTION_PREFIX: ${{ inputs.branch_convention_prefix }}
        PR_TITLE: ${{ inputs.pr_title }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        PR_TEMPLATE_PATH: ${{ inputs.pr_template_path }}
        TIMELINE_TEMPLATE_PATH: ${{ inputs.timeline_template_path }}
        ERRORS_PATH: ${{ inputs.errors }}
      run: |
        echo "::group::üîß Setup & Input Validation"

        if [ -n "${ERRORS_PATH:-}" ]; then
          mkdir -p "$(dirname "$ERRORS_PATH")"
          touch "$ERRORS_PATH" || true
        fi

        if [ -z "$TOKEN" ]; then
          echo "‚ùå [token] Obrigat√≥rio e n√£o informado. Sem este token a Action n√£o consegue chamar a API do GitHub (gh CLI, cria√ß√£o/edi√ß√£o de PR e coment√°rios)."
          echo "   ‚ûú Defina 'token' com 'secrets.GITHUB_TOKEN' ou um PAT com permiss√µes de leitura/escrita em PRs."
          exit 1
        else
          echo "‚úÖ [token] Informado. A Action poder√° criar/atualizar PRs e publicar coment√°rios."
        fi

        if [ -z "$PR_NUMBER" ]; then
          echo "‚ùå [pr_number] Obrigat√≥rio e n√£o informado. Sem este pr_number a Action n√£o consegue descobrir qual √© a branch destino da nova PR."
          echo "   ‚ûú Defina 'pr_number' com 'N' ou '#N' da PR origem."
          exit 1
        else
          echo "‚úÖ [pr_number] Informado. A Action descobrir√° dinamicamente qual √© a branch destino da nova PR."
        fi

        if [ -z "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] Caminho n√£o informado. A Action precisa de um arquivo para anexar ao PR."
          echo "   ‚ûú Gere o relat√≥rio no job anterior e passe o caminho em 'attached_file_path' (ex.: 'reports/pmd-report.md')."
          exit 1
        elif [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] Arquivo '$ATTACHED_FILE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'attached_file_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [attached_file_path] Encontrado em '$ATTACHED_FILE_PATH'. Ser√° usado como base do arquivo publicado."
        fi

        if [ -z "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå  [pr_template_path] N√£o informado."
          echo "   ‚ûú Defina 'pr_template_path' com o caminho de um template customizado para personalizar o corpo do PR."
          exit 1
        elif [ ! -f "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå [pr_template_path] Arquivo '$PR_TEMPLATE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'attached_file_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [pr_template_path] Encontrado em '$PR_TEMPLATE_PATH'. Ser√° usado para exibir a descri√ß√£o da Pull Request."
        fi

        if [ -z "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå  [timeline_template_path] N√£o informado."
          echo "   ‚ûú Defina 'timeline_template_path' com o caminho de um template customizado para personalizar a mensqgem do timeline na PR."
          exit 1
        elif [ ! -f "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå [timeline_template_path] Arquivo '$TIMELINE_TEMPLATE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'timeline_template_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [timeline_template_path] Encontrado em '$TIMELINE_TEMPLATE_PATH'. Ser√° usado para exibir a mensagem no timeline da Pull Request."
        fi

        if [ -z "$ERRORS_PATH" ]; then
          echo "‚ÑπÔ∏è [errors] N√£o informado."
          echo "   ‚ûú Defina 'errors' com o caminho de um arquivo de log customizado para personalizar as saidas de erros deste workflow."
        elif [ ! -f "$ERRORS_PATH" ]; then
          echo "‚ÑπÔ∏è [errors] Arquivo '$ERRORS_PATH' n√£o encontrado."
          echo "   ‚ûú Um arquivo vazio ser√° criado para esta Action e nele ser√£o adicionados os erros, caso ocorram."
        else
          echo "‚úÖ [timeline_template_path] Encontrado em '$TIMELINE_TEMPLATE_PATH'. Ser√° usado para exibir a mensagem no timeline da Pull Request."
        fi

        if [ -z "$BRANCH_CONVENTION_PREFIX" ]; then
          echo "‚ÑπÔ∏è [branch_convention_prefix] N√£o informado. Branches de relat√≥rio ser√£o criados sem prefixo dedicado, podendo conflitar com branches de desenvolvimento."
          echo "   ‚ûú Defina um prefixo para isolar branches de relat√≥rio: '<prefix>/<branch_origem>'."
        else
          echo "‚ÑπÔ∏è [branch_convention_prefix] Usando prefixo: '<prefix>/<sufixo_commit>'."
          echo "   ‚ûú Os branches de relat√≥rio ser√£o criados como '<prefix>/<sufixo_commit>'."
        fi

        if [ -z "$PR_TITLE" ]; then
          echo "‚ÑπÔ∏è [pr_title] N√£o informado. O PR poder√° ser criado sem t√≠tulo claro, dificultando a leitura na lista de PRs."
          echo "   ‚ûú Defina 'pr_title' com um t√≠tulo descritivo (ex.: 'üõ°Ô∏è Automated Pull Request')."
        else
          echo "‚ÑπÔ∏è [pr_title] T√≠tulo configurado como: '$PR_TITLE'."
          echo "   ‚ûú Este valor ser√° usado como t√≠tulo dos PRs de relat√≥rio."
        fi

        if [ -z "$BOT_EMAIL" ]; then
          echo "‚ÑπÔ∏è [bot_email] N√£o informado. O git usar√° o email padr√£o do ambiente e isso pode quebrar a prote√ß√£o de loop baseada no autor."
          echo "   ‚ûú Defina 'bot_email' (ex.: 'git-pr-ops@users.noreply.github.com') para: "
          echo "      - identificar os commits do bot; "
          echo "      - permitir que o circuito anti-loop funcione corretamente."
        else
          echo "‚ÑπÔ∏è [bot_email] Usando: '$BOT_EMAIL'."
          echo "   ‚ûú Este email ser√° configurado como autor dos commits e usado na verifica√ß√£o de loops."
        fi

        echo "‚úÖ Input validation complete."
        echo "::endgroup::"

    - id: pr_info
      name: "üîç Obter informa√ß√µes da PR de origem"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        ERRORS_PATH: ${{ inputs.errors }}
      run: |
        set -euo pipefail

        if [ -n "${ERRORS_PATH:-}" ]; then
          mkdir -p "$(dirname "$ERRORS_PATH")"
          touch "$ERRORS_PATH" || true
        fi

        append_error_log() {
          if [ -z "${ERRORS_PATH:-}" ]; then
            return 0
          fi
          local ctx="$1"
          local f="$2"
          if [ -s "$f" ]; then
            printf '\n[%s] %s\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" "$ctx" >> "$ERRORS_PATH" || true
            cat "$f" >> "$ERRORS_PATH" || true
            printf '\n' >> "$ERRORS_PATH" || true
          fi
        }

        if ! gh auth status >/dev/null 2>&1; then
          err="$(mktemp)"
          if ! gh auth login --with-token <<<"$GH_TOKEN" >/dev/null 2>"$err"; then
            append_error_log "pr_info: gh auth login" "$err"
            cat "$err" >&2
            rm -f "$err"
            exit 1
          fi
          append_error_log "pr_info: gh auth login (stderr)" "$err"
          rm -f "$err"
        fi

        err="$(mktemp)"
        if ! PR_JSON="$(gh pr view "$PR_NUMBER" --json url,title,headRefName,headRefOid,baseRefName,baseRefOid 2>"$err")"; then
          append_error_log "pr_info: gh pr view" "$err"
          cat "$err" >&2
          rm -f "$err"
          exit 1
        fi
        append_error_log "pr_info: gh pr view (stderr)" "$err"
        rm -f "$err"

        PR_URL=$(echo "$PR_JSON" | jq -r '.url')
        PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')

        DEST_BRANCH_NAME=$(echo "$PR_JSON" | jq -r '.baseRefName')
        DEST_BRANCH_SHA=$(echo "$PR_JSON" | jq -r '.baseRefOid')

        SOURCE_BRANCH_NAME=$(echo "$PR_JSON" | jq -r '.headRefName')
        SOURCE_BRANCH_SHA=$(echo "$PR_JSON" | jq -r '.headRefOid')

        echo "PR_URL=$PR_URL"
        echo "PR_TITLE=$PR_TITLE"
        echo "DEST_BRANCH_NAME=$DEST_BRANCH_NAME"
        echo "DEST_BRANCH_SHA=$DEST_BRANCH_SHA"
        echo "SOURCE_BRANCH_NAME=$SOURCE_BRANCH_NAME"
        echo "SOURCE_BRANCH_SHA=$SOURCE_BRANCH_SHA"

        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "pr_title=$PR_TITLE" >> "$GITHUB_OUTPUT"
        echo "dest_branch_name=$DEST_BRANCH_NAME" >> "$GITHUB_OUTPUT"
        echo "dest_branch_sha=$DEST_BRANCH_SHA" >> "$GITHUB_OUTPUT"
        echo "source_branch_name=$SOURCE_BRANCH_NAME" >> "$GITHUB_OUTPUT"
        echo "source_branch_sha=$SOURCE_BRANCH_SHA" >> "$GITHUB_OUTPUT"

    - name: "üîÅ Encontrar PRs derivadas"
      id: derivated_prs_finder
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        SOURCE_BRANCH: ${{ steps.pr_info.outputs.source_branch_name }}
        ERRORS_PATH: ${{ inputs.errors }}
      run: |
        set -euo pipefail

        if [ -n "${ERRORS_PATH:-}" ]; then
          mkdir -p "$(dirname "$ERRORS_PATH")"
          touch "$ERRORS_PATH" || true
        fi

        append_error_log() {
          if [ -z "${ERRORS_PATH:-}" ]; then
            return 0
          fi
          local ctx="$1"
          local f="$2"
          if [ -s "$f" ]; then
            printf '\n[%s] %s\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" "$ctx" >> "$ERRORS_PATH" || true
            cat "$f" >> "$ERRORS_PATH" || true
            printf '\n' >> "$ERRORS_PATH" || true
          fi
        }

        if ! gh auth status >/dev/null 2>&1; then
          err="$(mktemp)"
          if ! gh auth login --with-token <<<"$GH_TOKEN" >/dev/null 2>"$err"; then
            append_error_log "derivated_prs_finder: gh auth login" "$err"
            cat "$err" >&2
            rm -f "$err"
            exit 1
          fi
          append_error_log "derivated_prs_finder: gh auth login (stderr)" "$err"
          rm -f "$err"
        fi

        if [ -z "$SOURCE_BRANCH" ]; then
          echo "‚ö† SOURCE_BRANCH vazio. Nada a fazer."
          exit 0
        fi

        err="$(mktemp)"
        if ! PR_LIST="$(gh pr list --state open --base "$SOURCE_BRANCH" --json number,url,headRefName,baseRefName 2>"$err")"; then
          append_error_log "derivated_prs_finder: gh pr list" "$err"
          cat "$err" >&2
          rm -f "$err"
          exit 1
        fi
        append_error_log "derivated_prs_finder: gh pr list (stderr)" "$err"
        rm -f "$err"

        COUNT=$(echo "$PR_LIST" | jq 'length')

        echo "üîç PRs derivadas abertas com destino em '$SOURCE_BRANCH': total=$COUNT"

        echo "$PR_LIST" | jq -c '.[]' | while read -r pr; do
          NUM=$(echo "$pr" | jq -r '.number')
          URL=$(echo "$pr" | jq -r '.url')
          HEAD=$(echo "$pr" | jq -r '.headRefName')
          BASE=$(echo "$pr" | jq -r '.baseRefName')

          echo "- #$NUM $URL"
          echo "  head: $HEAD"
          echo "  base: $BASE"
        done

        echo "derived_count=$COUNT" >> "$GITHUB_OUTPUT"
        echo "derived_prs_json=$PR_LIST" >> "$GITHUB_OUTPUT"

    - id: branch_convention
      name: "ü™æ Branch Convention"
      shell: bash
      env:
        BRANCH_CONVENTION_PREFIX: ${{ inputs.branch_convention_prefix }}
      run: |
        set -euo pipefail
        echo "::group::ü™æ Define branch convention"

        if [ -z "${BRANCH_CONVENTION_PREFIX:-}" ]; then
          BRANCH_CONVENTION_PREFIX="ops/report/latest"
        fi

        git fetch --all --prune --quiet

        LATEST_SHA="$(git rev-parse HEAD)"
        CUSTOM_SUFFIX="${LATEST_SHA: -10}"

        BRANCH_CONVENTION="${BRANCH_CONVENTION_PREFIX}/${CUSTOM_SUFFIX}"

        echo "prefix: $BRANCH_CONVENTION_PREFIX"
        echo "latest_sha: $LATEST_SHA"
        echo "custom_suffix: $CUSTOM_SUFFIX"
        echo "branch_convention: $BRANCH_CONVENTION"

        echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    - id: commit_attached_file
      name: "üìù Commit File"
      shell: bash
      env:
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        BOT_NAME: ${{ inputs.bot_name }}
      run: |
        set -euo pipefail
        echo "::group::üìù Commit file"
        echo "branch_convention: $BRANCH_CONVENTION"
        echo "attached_file_path: $ATTACHED_FILE_PATH"

        if [ -z "${BRANCH_CONVENTION:-}" ]; then
          echo "‚ùå BRANCH_CONVENTION vazio. Verifique o bloco branch_convention."
          echo "::endgroup::"
          exit 1
        fi

        git fetch --all --prune --quiet

        if git show-ref --verify --quiet "refs/heads/$BRANCH_CONVENTION"; then
          echo "‚Ñπ Branch j√° existe localmente: $BRANCH_CONVENTION"
          git checkout "$BRANCH_CONVENTION"
        else
          if git ls-remote --exit-code --heads origin "$BRANCH_CONVENTION" >/dev/null 2>&1; then
            echo "‚Ñπ Branch existe no remoto, criando tracking local: $BRANCH_CONVENTION"
            git checkout -q -b "$BRANCH_CONVENTION" "origin/$BRANCH_CONVENTION"
          else
            echo "üÜï Criando nova branch a partir do HEAD atual: $BRANCH_CONVENTION"
            git checkout -q -b "$BRANCH_CONVENTION"
          fi
        fi

        if [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå Arquivo de relat√≥rio n√£o encontrado: $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 1
        fi

        git config user.email "$BOT_EMAIL"
        if [ -n "${BOT_NAME:-}" ]; then
          git config user.name "$BOT_NAME"
        fi

        git add "$ATTACHED_FILE_PATH"

        if git diff --cached --quiet; then
          echo "‚ö†Ô∏è Nenhuma altera√ß√£o para commitar em $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 0
        fi

        git commit -m "chore(attach): update attached file"
        git push origin "$BRANCH_CONVENTION"

        COMMIT_SHA="$(git rev-parse HEAD)"
        echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"
        echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
        echo "‚úÖ Attached file commit realizado em $BRANCH_CONVENTION (commit $COMMIT_SHA)"
        echo "::endgroup::"

    - name: "ü™Ñ Exportar basename ATTACHED_FILE_PATH"
      id: reexport_basename_attached_file
      shell: bash
      env:
        PR_NUMBER: ${{ inputs.pr_number }}
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
      run: |
        set -euo pipefail
        FILENAME="$(basename "$ATTACHED_FILE_PATH")"
        echo "Basename for ATTACHED_FILE_PATH: $FILENAME"
        echo "PR_NUMBER for inputs.attached_file_path: $PR_NUMBER"
        echo "ATTACHED_FILE_PATH=$FILENAME" >> "$GITHUB_ENV"
        echo "PR_NUMBER=$PR_NUMBER" >> "$GITHUB_ENV"

    - name: "ü™Ñ Exportar vari√°veis para o PR template"
      id: export_vars_pr_template
      shell: bash
      run: |
        set -euo pipefail
        env | grep -v '^GITHUB_' | while IFS='=' read -r key value; do
          printf '%s=%s\n' "$key" "$value" >> "$GITHUB_ENV"
        done

    - name: "üìÑ Render PR template"
      id: render_pr
      uses: Malnati/template-render@v1.0.1
      with:
        template: ${{ inputs.pr_template_path }}
        output: /tmp/hardcode-pr.md

    - id: publish_pr
      name: "üöÄ Publishing Pull Request"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        BASE_BRANCH: ${{ steps.pr_info.outputs.source_branch_name }}
        HEAD_BRANCH: ${{ steps.commit_attached_file.outputs.branch_convention }}
        TITLE: ${{ inputs.pr_title }}
        PR_TEMPLATE_PATH: ${{ steps.render_pr.outputs.path }}
        HEAD_PREFIX: ops/files/
        ERRORS_PATH: ${{ inputs.errors }}
      run: |
        set -euo pipefail

        if [ -n "${ERRORS_PATH:-}" ]; then
          mkdir -p "$(dirname "$ERRORS_PATH")"
          touch "$ERRORS_PATH" || true
        fi

        append_error_log() {
          if [ -z "${ERRORS_PATH:-}" ]; then
            return 0
          fi
          local ctx="$1"
          local f="$2"
          if [ -s "$f" ]; then
            printf '\n[%s] %s\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" "$ctx" >> "$ERRORS_PATH" || true
            cat "$f" >> "$ERRORS_PATH" || true
            printf '\n' >> "$ERRORS_PATH" || true
          fi
        }

        if ! gh auth status >/dev/null 2>&1; then
          err="$(mktemp)"
          if ! gh auth login --with-token <<<"$GH_TOKEN" >/dev/null 2>"$err"; then
            append_error_log "publish_pr: gh auth login" "$err"
            cat "$err" >&2
            rm -f "$err"
            exit 1
          fi
          append_error_log "publish_pr: gh auth login (stderr)" "$err"
          rm -f "$err"
        fi

        err="$(mktemp)"
        if ! EXISTING_URL="$(gh pr list --state open --base "$BASE_BRANCH" --json url,headRefName --jq '([.[] | select(.headRefName | startswith(env.HEAD_PREFIX))][0].url) // ""' 2>"$err")"; then
          append_error_log "publish_pr: gh pr list (existing url)" "$err"
          cat "$err" >&2
          rm -f "$err"
          exit 1
        fi
        append_error_log "publish_pr: gh pr list (existing url) (stderr)" "$err"
        rm -f "$err"

        if [ -n "${EXISTING_URL:-}" ]; then
          echo "PR_URL: $EXISTING_URL"
          echo "pr_url=$EXISTING_URL" >> "$GITHUB_OUTPUT"
          echo "pr_state=OPEN" >> "$GITHUB_OUTPUT"
        else
          err="$(mktemp)"
          if ! gh pr create --base "$BASE_BRANCH" --head "$HEAD_BRANCH" --title "$TITLE" --body-file "$PR_TEMPLATE_PATH" >/dev/null 2>"$err"; then
            append_error_log "publish_pr: gh pr create" "$err"
            cat "$err" >&2
            rm -f "$err"
            exit 1
          fi
          append_error_log "publish_pr: gh pr create (stderr)" "$err"
          rm -f "$err"

          err="$(mktemp)"
          if ! PR_URL="$(gh pr view "$HEAD_BRANCH" --json url --jq '.url' 2>"$err")"; then
            append_error_log "publish_pr: gh pr view (url)" "$err"
            cat "$err" >&2
            rm -f "$err"
            exit 1
          fi
          append_error_log "publish_pr: gh pr view (url) (stderr)" "$err"
          rm -f "$err"

          echo "PR_URL: $PR_URL"
          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "pr_state=OPEN" >> "$GITHUB_OUTPUT"
        fi

    - name: "üìÑ Render timeline template"
      id: render_timeline
      uses: Malnati/template-render@v1.0.1
      with:
        template: ${{ inputs.timeline_template_path }}
        output: /tmp/hardcode-timeline.md

    - id: timeline_notification
      name: "üîî Notify over PR Timeline"
      uses: Malnati/pr-comment@v8.0.2
      with:
        token: ${{ inputs.token }}
        pr_number: ${{ inputs.pr_number }}
        template_path: ${{ steps.render_timeline.outputs.path }}
