# Malnati/git-report-ops@v1.1.2
name: "Git Report Ops"
description: "Engine GitOps v1.1.1: Fix de newlines e formata√ß√£o aprimorada da PR."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  report_file:
    description: "Arquivo Markdown para publicar."
    required: true
  scan_extensions:
    description: "Extens√µes para assinatura."
    required: false
    default: "ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml"
  scan_exclude:
    description: "Caminhos ignorados."
    required: false
    default: "node_modules|dist|build|.git|.github"
  report_branch_prefix:
    description: "Prefixo da branch."
    required: false
    default: "audit/report"
  pr_title:
    description: "T√≠tulo da PR."
    required: false
    default: "üõ°Ô∏è Automated Audit Report"
  pr_body:
    description: "Corpo base da PR."
    required: false
    default: "Relat√≥rio de auditoria gerado automaticamente."
  bot_email:
    description: "Email do bot."
    required: false
    default: "git-report-ops@users.noreply.github.com"
  pr_template_path:
    description: "Caminho para um template Markdown customizado para o corpo da PR."
    required: false
    default: ""

outputs:
  pr_url:
    description: "URL da Pull Request."
    value: ${{ steps.publish.outputs.pr_url }}
  status:
    description: "Status da opera√ß√£o."
    value: ${{ steps.logic_controller.outputs.status }}

runs:
  using: "composite"
  steps:
    # ==================================================================
    # BLOCK 1: INITIALIZATION & VALIDATION (Split)
    # ==================================================================
    
    # 1.0 - Valida√ß√£o de Seguran√ßa
    - id: validate_token
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
      run: |
        echo "::group::üîê Validation: Token"
        if [ -z "$TOKEN" ]; then 
           echo "‚ùå Error: Input 'token' is missing."
           echo "   Please provide a valid GitHub Token with permissions:"
           echo "   - contents: write"
           echo "   - pull-requests: write"
           exit 1
        fi
        echo "‚úÖ Token present."
        echo "::endgroup::"

    # 1.1 - Valida√ß√£o de Arquivo (Input)
    - id: validate_report
      shell: bash
      env:
        REPORT: ${{ inputs.report_file }}
      run: |
        echo "::group::üìÑ Validation: Report File"
        if [ ! -f "$REPORT" ]; then 
           echo "‚ùå Error: Report file not found at: '$REPORT'"
           echo "   Make sure the previous step generated the artifact correctly."
           exit 1
        fi
        echo "‚úÖ Report file found: $REPORT"
        echo "::endgroup::"

    # 1.2 - Configura√ß√£o de Ambiente Git
    - id: git_config
      shell: bash
      env:
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üîß Git Config: Identity"
        
        # Configura identidade para este job
        git config user.name "git-report-ops-bot"
        git config user.email "$BOT_EMAIL"
        
        echo "‚úÖ Git identity configured:"
        echo "   Name:  git-report-ops-bot"
        echo "   Email: $BOT_EMAIL"
        echo "::endgroup::"
        
    # ==================================================================
    # BLOCK 2: CIRCUIT BREAKER (Split)
    # ==================================================================

    # 2.0 - Prote√ß√£o por Nome da Branch
    - id: check_branch
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
      run: |
        echo "::group::üõ°Ô∏è Anti-Loop: Branch Name Check"
        echo "Target Branch: $HEAD_REF"
        echo "Report Prefix: $PREFIX"
        
        if [[ "$HEAD_REF" == "$PREFIX"* ]]; then
           echo "üõë Loop Detected: Running inside a report branch."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
        else
           echo "‚úÖ Branch check passed."
           echo "skip=false" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # 2.1 - Prepara√ß√£o do Hist√≥rico (Fetch)
    # S√≥ roda se o passo anterior n√£o bloqueou
    - id: fetch_history
      if: steps.check_branch.outputs.skip != 'true'
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
      run: |
        echo "::group::üìö Git History: Fetching Context"
        if [ -f .git/shallow ]; then
           echo "‚öôÔ∏è Shallow repo detected. Fetching depth 1 for author check..."
           git fetch --depth=1 origin "$HEAD_REF" 2>/dev/null || true
        else
           echo "‚úÖ Full history available."
        fi
        echo "::endgroup::"

    # 2.2 - Prote√ß√£o por Autor do Commit
    # S√≥ roda se o passo 2.0 n√£o bloqueou
    - id: check_author
      if: steps.check_branch.outputs.skip != 'true'
      shell: bash
      env:
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üõ°Ô∏è Anti-Loop: Commit Author Check"
        
        LAST_AUTHOR=$(git log -1 --pretty=format:'%ae')
        echo "Last Commit Author: $LAST_AUTHOR"
        echo "Bot Email: $BOT_EMAIL"

        if [[ "$LAST_AUTHOR" == "$BOT_EMAIL" ]]; then
           echo "üõë Loop Detected: Last commit was made by the bot."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
        else
           echo "‚úÖ Author check passed."
           echo "skip=false" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 3: IDEMPOTENCY CHECK (Split)
    # ==================================================================

    # 3.0 - C√°lculo da Assinatura do C√≥digo (Refatorado: Step-by-Step)
    - id: calc_signature
      # Verifica os dois skips do Bloco 2
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      env:
        EXTS: ${{ inputs.scan_extensions }}
        EXCLUDE: ${{ inputs.scan_exclude }}
      run: |
        echo "::group::üßÆ Idempotency: Calculating Signature"
        set -euo pipefail

        # Defini√ß√£o de arquivos tempor√°rios
        ALL_FILES="/tmp/files_all.txt"
        EXT_MATCHES="/tmp/files_extensions.txt"
        FINAL_LIST="/tmp/files_final.txt"
        HASH_LIST="/tmp/object_hashes.txt"

        # 1. Listar todos os arquivos do HEAD
        echo "üìÇ 1. Listando arquivos do reposit√≥rio..."
        git ls-tree -r HEAD --name-only > "$ALL_FILES"
        COUNT_ALL=$(wc -l < "$ALL_FILES")
        echo "   -> Total encontrado: $COUNT_ALL arquivos."

        # 2. Filtrar por Extens√£o
        # Usa '|| true' para n√£o quebrar o script caso grep n√£o ache nada (exit code 1)
        echo "üîç 2. Filtrando por extens√µes: .($EXTS)"
        grep -E "\.($EXTS)$" "$ALL_FILES" > "$EXT_MATCHES" || true
        COUNT_EXT=$(wc -l < "$EXT_MATCHES")
        echo "   -> Arquivos compat√≠veis: $COUNT_EXT"

        # 3. Remover Exclus√µes
        echo "üóëÔ∏è 3. Removendo padr√µes ignorados: $EXCLUDE"
        grep -vE "$EXCLUDE" "$EXT_MATCHES" > "$FINAL_LIST" || true
        COUNT_FINAL=$(wc -l < "$FINAL_LIST")
        echo "   -> Arquivos para assinatura: $COUNT_FINAL"

        # 4. Calcular Hash dos Objetos
        echo "#Ô∏è‚É£ 4. Gerando hash dos objetos..."
        if [ -s "$FINAL_LIST" ]; then
           # xargs: -a (l√™ arquivo), -d (delimitador newline), -r (n√£o roda se vazio)
           xargs -a "$FINAL_LIST" -d '\n' -r git hash-object > "$HASH_LIST"
           
           # Calcula MD5 da lista de hashes para gerar assinatura √∫nica
           SIGNATURE=$(md5sum "$HASH_LIST" | awk '{print $1}')
        else
           echo "   ‚ö†Ô∏è Aviso: Nenhum arquivo restante para c√°lculo. Assinatura ser√° 'empty'."
           SIGNATURE="empty"
        fi

        echo "üîë Content Signature: $SIGNATURE"
        
        # Exporta para ENV
        echo "CODE_SIGNATURE=$SIGNATURE" >> "$GITHUB_ENV"
        echo "::endgroup::"

    # 3.1 - Inje√ß√£o de Metadados no Relat√≥rio
    - id: prep_report
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      env:
        REPORT: ${{ inputs.report_file }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
      run: |
        echo "::group::üìù Report: Injecting Metadata"
        
        TEMP="/tmp/meta_report.md"
        echo "" > "$TEMP"
        echo "> **Content Signature:** $SIGNATURE" >> "$TEMP"
        echo "> **Source SHA:** $HEAD_SHA" >> "$TEMP"
        echo "> **Data:** $(date -u)" >> "$TEMP"
        echo "" >> "$TEMP"
        cat "$REPORT" >> "$TEMP"
        
        # Substitui arquivo original
        mv "$TEMP" "$REPORT"
        echo "‚úÖ Metadata added to $REPORT"
        echo "::endgroup::"
        
    # 3.2 - Prepara√ß√£o do Hist√≥rico Git
    # Garante que temos o hist√≥rico completo para buscar refer√™ncias antigas
    - id: fetch_history
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      run: |
        echo "::group::üìö Idempotency: Fetching History"
        set -euo pipefail

        if [ -f .git/shallow ]; then 
           echo "‚öôÔ∏è  Repo is shallow. Unshallowing..."
           git fetch --unshallow 2>/dev/null || true
        else
           echo "‚úÖ Repo is already deep."
        fi

        echo "üîÑ Fetching all refs..."
        git fetch --all --quiet
        echo "::endgroup::"

    # 3.3 - Execu√ß√£o da Busca (Search Strategy)
    # Filtra commits do bot e busca a assinatura dentro deles
    - id: search_history
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      env:
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üïµÔ∏è Idempotency: Scanning Commits"
        set -euo pipefail

        # Arquivos tempor√°rios
        COMMITS_FILE="/tmp/bot_commits.txt"
        RESULT_FILE="/tmp/found_ref.txt"
        
        SEARCH_STRING="> **Content Signature:** $SIGNATURE"
        
        echo "üîç 1. Filtrando commits do autor: $BOT_EMAIL"
        # Lista todos os commits (--all) filtrados pelo autor
        git rev-list --all --author="$BOT_EMAIL" > "$COMMITS_FILE"
        
        COMMIT_COUNT=$(wc -l < "$COMMITS_FILE")
        echo "   -> Encontrados $COMMIT_COUNT commits do bot."

        if [ "$COMMIT_COUNT" -eq "0" ]; then
           echo "‚ö™ Nenhum commit anterior do bot para analisar."
           echo "" > "$RESULT_FILE"
        else
           echo "üîç 2. Buscando assinatura nos arquivos Markdown..."
           echo "   Key: '$SEARCH_STRING'"
           
           # Passa a lista de commits para o git grep via xargs
           # -I: ignora bin√°rios, -F: string fixa, -l: apenas nomes de arquivos
           # || true impede falha se n√£o encontrar nada
           cat "$COMMITS_FILE" | xargs -r git grep -I -F -l "$SEARCH_STRING" -- "*.md" | head -n 1 > "$RESULT_FILE" || true
        fi
        
        # Debug do resultado
        if [ -s "$RESULT_FILE" ]; then
           echo "‚úÖ Encontrado: $(cat "$RESULT_FILE")"
        else
           echo "‚ö™ Nada encontrado."
        fi
        
        echo "::endgroup::"

    # 3.4 - An√°lise do Resultado e Defini√ß√£o de Outputs
    - id: analyze_search
      if: steps.check_branch.outputs.skip != 'true' && steps.check_author.outputs.skip != 'true'
      shell: bash
      run: |
        echo "::group::decission Idempotency: Decision Logic"
        set -euo pipefail
        
        RESULT_FILE="/tmp/found_ref.txt"
        
        if [ -s "$RESULT_FILE" ]; then
           FOUND_REF=$(cat "$RESULT_FILE")
           
           echo "‚úÖ Relat√≥rio V√°lido Encontrado: $FOUND_REF"
           echo "found=true" >> "$GITHUB_OUTPUT"
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_IDEMPOTENT" >> "$GITHUB_OUTPUT"
           
           # Extrai SHA do commit (formato SHA:path/to/file)
           SHA=$(echo "$FOUND_REF" | cut -d':' -f1)
           echo "commit_sha=$SHA" >> "$GITHUB_OUTPUT"
           echo "   -> Commit SHA extra√≠do: $SHA"
        else
           echo "üìù Nenhuma correspond√™ncia encontrada. O conte√∫do √© novo."
           echo "found=false" >> "$GITHUB_OUTPUT"
           echo "skip=false" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # 3.5 - Recupera√ß√£o de URL (Apenas se achou hist√≥rico)
    - id: recover_url
      # Nota: 'analyze_search' √© o ID do passo 3.4 definido anteriormente
      if: steps.analyze_search.outputs.found == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        COMMIT_SHA: ${{ steps.analyze_search.outputs.commit_sha }}
        PREFIX: ${{ inputs.report_branch_prefix }}
      run: |
        echo "::group::üîó Idempotency: Recovering PR URL"
        set -euo pipefail

        echo "üîç 1. Buscando branches remotas que cont√©m o commit $COMMIT_SHA..."
        
        # Estrat√©gia de Busca:
        # 1. git branch -r --contains: Lista branches remotas com esse commit
        # 2. grep "$PREFIX": Filtra apenas as branches de relat√≥rio (ex: sentinel/audit/...)
        # 3. sed: Remove o prefixo 'origin/' para ter o nome limpo da branch
        
        TARGET_BRANCH=$(git branch -r --contains "$COMMIT_SHA" \
          | grep "$PREFIX" \
          | head -n 1 \
          | sed 's/^[[:space:]]*origin\///' \
          | xargs || true)

        if [ -n "$TARGET_BRANCH" ]; then
           echo "   -> Branch de relat√≥rio identificada: $TARGET_BRANCH"

           echo "üîç 2. Consultando API do GitHub por PRs abertas..."
           # Busca PR associada √† branch head encontrada
           PR_URL=$(gh pr list --head "$TARGET_BRANCH" --state open --json url -q .[0].url || true)

           if [ -n "$PR_URL" ] && [ "$PR_URL" != "null" ]; then
              echo "‚úÖ URL recuperada com sucesso: $PR_URL"
              echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
           else
              echo "‚ö†Ô∏è Aviso: Branch encontrada, mas n√£o h√° PR aberta associada."
           fi
        else
           echo "‚ö†Ô∏è Aviso: N√£o foi poss√≠vel rastrear a branch a partir do commit."
           echo "   Causa prov√°vel: A branch de relat√≥rio antiga foi deletada, mas o commit persiste (dangling)."
        fi
        
        echo "::endgroup::"
        
    # ==================================================================
    # BLOCK 4: PUBLISH (Refatorado: Template-Based)
    # ==================================================================

    # 4.0 - Opera√ß√µes Git (Branch & Push)
    - id: git_push
      if: steps.circuit_breaker.outputs.skip != 'true' && steps.analyze_search.outputs.skip != 'true'
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
        REPORT: ${{ inputs.report_file }}
      run: |
        echo "::group::üöÄ Git: Pushing Report Branch"
        set -euo pipefail
        
        REPORT_BRANCH="${PREFIX}/${HEAD_REF}"
        
        # Garante checkout limpo da origem
        git checkout "$HEAD_REF"
        # Cria/Reseta branch de relat√≥rio
        git checkout -B "$REPORT_BRANCH"
        
        git add "$REPORT"
        git commit -m "docs: automated report update [skip ci]"
        git push -f origin "$REPORT_BRANCH"
        
        echo "branch=$REPORT_BRANCH" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # 4.1 - Constru√ß√£o do Corpo da PR (Envsubst)
    # Substitui o Heredoc por processamento de arquivo de template
    - id: build_body
      if: steps.circuit_breaker.outputs.skip != 'true' && steps.analyze_search.outputs.skip != 'true'
      shell: bash
      env:
        # Vari√°veis para substitui√ß√£o
        PR_NUM: ${{ github.event.pull_request.number }}
        HEAD_REF: ${{ github.head_ref }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
        USER_BODY: ${{ inputs.pr_body }}
        # Configura√ß√£o de Template
        CUSTOM_TEMPLATE: ${{ inputs.pr_template_path }}
        DEFAULT_TEMPLATE: ${{ github.action_path }}/templates/pr-body-default.md
      run: |
        echo "::group::üìù PR: Building Description from Template"
        set -euo pipefail
        
        BODY_FILE="/tmp/pr_description.md"
        export DATE=$(date -u)
        
        # 1. Sele√ß√£o do Template
        if [[ -n "$CUSTOM_TEMPLATE" && -f "$CUSTOM_TEMPLATE" ]]; then
           echo "üìÑ Using custom template: $CUSTOM_TEMPLATE"
           TEMPLATE_SOURCE="$CUSTOM_TEMPLATE"
        else
           echo "üìÑ Using default template."
           if [ ! -f "$DEFAULT_TEMPLATE" ]; then
              echo "‚ùå Critical: Default template not found at $DEFAULT_TEMPLATE"
              exit 1
           fi
           TEMPLATE_SOURCE="$DEFAULT_TEMPLATE"
        fi
        
        # 2. Processamento (Substitui√ß√£o de Vari√°veis)
        # envsubst substitui $VAR pelo valor da vari√°vel de ambiente no arquivo
        envsubst < "$TEMPLATE_SOURCE" > "$BODY_FILE"
        
        # 3. Inje√ß√£o Obrigat√≥ria de Assinatura (Hidden)
        # Isso garante que a l√≥gica de rastreabilidade funcione independente do template do usu√°rio
        echo "" >> "$BODY_FILE"
        echo "" >> "$BODY_FILE"
        
        echo "‚úÖ Body generated at: $BODY_FILE"
        echo "body_file=$BODY_FILE" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # 4.2 - Gerenciamento da PR (Create/Edit)
    - id: publish
      if: steps.circuit_breaker.outputs.skip != 'true' && steps.analyze_search.outputs.skip != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        HEAD_REF: ${{ github.head_ref }}
        REPORT_BRANCH: ${{ steps.git_push.outputs.branch }}
        TITLE: ${{ inputs.pr_title }}
        BODY_FILE: ${{ steps.build_body.outputs.body_file }}
      run: |
        echo "::group::üì° API: Managing Pull Request"
        set -euo pipefail
        
        # 1. Tenta Criar
        gh pr create \
          --base "$HEAD_REF" \
          --head "$REPORT_BRANCH" \
          --title "$TITLE" \
          --body-file "$BODY_FILE" || echo "‚ö†Ô∏è PR creation skipped (likely exists)."
          
        # 2. Recupera URL
        PR_URL=$(gh pr view "$REPORT_BRANCH" --json url -q .url)
        
        if [ -z "$PR_URL" ]; then
           echo "‚ùå Failed to retrieve PR URL."
           exit 1
        fi

        # 3. For√ßa atualiza√ß√£o do Body (Garante metadados novos em PRs antigas)
        echo "üîÑ Updating PR body..."
        gh pr edit "$PR_URL" --body-file "$BODY_FILE"
        
        echo "‚úÖ PR Link: $PR_URL"
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "status=PUBLISHED" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 5: LOGIC CONTROLLER (OUTPUT SUMMARY)
    # ==================================================================
    - id: logic_controller
      shell: bash
      if: always()
      env:
        S1: ${{ steps.circuit_breaker.outputs.reason }}
        S2: ${{ steps.idempotency.outputs.reason }}
        S3: ${{ steps.publish.outputs.status }}
      run: |
        FINAL_STATUS="UNKNOWN"
        if [ -n "$S3" ]; then FINAL_STATUS="$S3";
        elif [ -n "$S2" ]; then FINAL_STATUS="$S2";
        elif [ -n "$S1" ]; then FINAL_STATUS="$S1";
        fi
        echo "status=$FINAL_STATUS" >> "$GITHUB_OUTPUT"
