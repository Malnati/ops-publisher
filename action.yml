# Malnati/git-report-ops@v1.0.1
name: "Git Report Ops"
description: "Publica relatÃ³rios em PRs dedicadas com idempotÃªncia e proteÃ§Ã£o de loop."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token (com permissÃµes contents:write e pull-requests:write)."
    required: true
  
  # O que publicar?
  report_file:
    description: "Caminho do arquivo Markdown gerado pela ferramenta anterior."
    required: true
  
  # ConfiguraÃ§Ã£o da Assinatura (Para saber se o cÃ³digo mudou)
  scan_extensions:
    description: "Regex de extensÃµes para calcular a assinatura do cÃ³digo fonte."
    required: false
    default: "ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml"
  scan_exclude:
    description: "Regex de caminhos ignorados no cÃ¡lculo da assinatura."
    required: false
    default: "node_modules|dist|build|.git|.github"
  
  # PersonalizaÃ§Ã£o da PR
  report_branch_prefix:
    description: "Prefixo da branch de relatÃ³rio (ex: sentinel/audit)."
    required: false
    default: "audit/report"
  pr_title:
    description: "TÃ­tulo da Pull Request gerada."
    required: false
    default: "ðŸ›¡ï¸ Automated Audit Report"
  pr_body:
    description: "Corpo da Pull Request gerada."
    required: false
    default: "RelatÃ³rio de auditoria gerado automaticamente."
  bot_email:
    description: "Email utilizado para commits e verificaÃ§Ã£o de autoria (Anti-loop)."
    required: false
    default: "git-report-ops@users.noreply.github.com"

outputs:
  pr_url:
    description: "URL da Pull Request de relatÃ³rio (nova ou existente)."
    value: ${{ steps.publish.outputs.pr_url }}
  status:
    description: "Resultado da operaÃ§Ã£o: PUBLISHED, UPDATED, SKIPPED_IDEMPOTENT, SKIPPED_LOOP."
    value: ${{ steps.logic_controller.outputs.status }}

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 0: BOOTSTRAP & VALIDATION
    # ------------------------------------------------------------------
    - id: setup
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPORT: ${{ inputs.report_file }}
      run: |
        echo "::group::ðŸ”§ Git Report Ops: Setup"
        if [ -z "$TOKEN" ]; then echo "âŒ Token missing."; exit 1; fi
        if [ ! -f "$REPORT" ]; then echo "âŒ Report file not found: $REPORT"; exit 1; fi
        
        # Setup de identidade Git para este job
        git config user.name "git-report-ops-bot"
        git config user.email "${{ inputs.bot_email }}"
        echo "âœ… Setup complete."
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 1: CIRCUIT BREAKER (ANTI-LOOP)
    # ------------------------------------------------------------------
    - id: circuit_breaker
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::ðŸ›¡ï¸ Loop Protection"
        
        # 1. Check Branch Name
        if [[ "$HEAD_REF" == "$PREFIX"* ]]; then
           echo "ðŸ›‘ Loop Branch: Estamos rodando dentro de uma branch de relatÃ³rio."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
           exit 0
        fi

        # 2. Check Author (Auto-fetch history if needed)
        if [ -f .git/shallow ]; then git fetch --depth=1 origin "$HEAD_REF" 2>/dev/null || true; fi
        
        LAST_AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae')
        
        if [[ "$LAST_AUTHOR_EMAIL" == "$BOT_EMAIL" ]]; then
           echo "ðŸ›‘ Loop Bot: O Ãºltimo commit foi feito por este bot."
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_LOOP" >> "$GITHUB_OUTPUT"
           exit 0
        fi

        echo "âœ… Safe to proceed."
        echo "skip=false" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 2: SIGNATURE & IDEMPOTENCY CHECK
    # ------------------------------------------------------------------
    - id: idempotency
      if: steps.circuit_breaker.outputs.skip != 'true'
      shell: bash
      env:
        EXTS: ${{ inputs.scan_extensions }}
        EXCLUDE: ${{ inputs.scan_exclude }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        REPORT: ${{ inputs.report_file }}
      run: |
        echo "::group::ðŸ•µï¸ Idempotency Check (Signature)"
        
        # 1. Calcula Assinatura do CÃ³digo Fonte (Ignorando o relatÃ³rio)
        SIGNATURE=$(git ls-tree -r HEAD --name-only \
          | grep -E "\.($EXTS)$" \
          | grep -vE "$EXCLUDE" \
          | xargs -d '\n' git hash-object 2>/dev/null | md5sum | awk '{print $1}' || echo "empty")
        
        echo "ðŸ”‘ Assinatura Calculada: $SIGNATURE"

        # 2. Prepara o arquivo final com Metadados
        # Adicionamos o Header no topo do arquivo fornecido pelo usuÃ¡rio
        TEMP_FILE="/tmp/final_report_with_meta.md"
        
        echo "<!-- METADATA BLOCK -->" > "$TEMP_FILE"
        echo "> **Content Signature:** $SIGNATURE" >> "$TEMP_FILE"
        echo "> **Source SHA:** $HEAD_SHA" >> "$TEMP_FILE"
        echo "> **Data:** $(date -u)" >> "$TEMP_FILE"
        echo "" >> "$TEMP_FILE"
        cat "$REPORT" >> "$TEMP_FILE"
        
        # Substitui o arquivo original pelo versÃ£o com metadados
        mv "$TEMP_FILE" "$REPORT"

        # 3. Busca HistÃ³rica
        if [ -f .git/shallow ]; then git fetch --unshallow 2>/dev/null || true; fi
        git fetch --all --quiet

        SEARCH_KEY="> **Content Signature:** $SIGNATURE"
        echo "ðŸ” Buscando assinatura no histÃ³rico do bot..."
        
        FOUND_REF=$(git grep -I -F -l "$SEARCH_KEY" $(git rev-list --all --author="$BOT_EMAIL") -- "*.md" 2>/dev/null | head -n 1 || true)

        if [ -n "$FOUND_REF" ]; then
           echo "âœ… RelatÃ³rio jÃ¡ existe para este cÃ³digo: $FOUND_REF"
           echo "skip=true" >> "$GITHUB_OUTPUT"
           echo "reason=SKIPPED_IDEMPOTENT" >> "$GITHUB_OUTPUT"
           
           # Tenta recuperar a URL da PR associada a essa branch de relatÃ³rio
           # Extrai o SHA do commit encontrado
           COMMIT_SHA=$(echo "$FOUND_REF" | cut -d':' -f1)
           
           # Descobre a branch que aponta para esse commit (pode ser vÃ¡rias, pegamos a primeira do bot)
           EXISTING_BRANCH=$(git branch -r --contains "$COMMIT_SHA" | grep "origin/ops/" | head -n 1 | sed 's/origin\///' | xargs)
           
           if [ -n "$EXISTING_BRANCH" ]; then
              echo "ðŸ” Branch encontrada: $EXISTING_BRANCH"
              # Busca a PR aberta para essa branch
              EXISTING_URL=$(gh pr list --head "$EXISTING_BRANCH" --json url -q .[0].url)
              
              if [ -n "$EXISTING_URL" ]; then
                 echo "ðŸ”— PR Recuperada: $EXISTING_URL"
                 echo "pr_url=$EXISTING_URL" >> "$GITHUB_OUTPUT"
              fi
           fi
        else
          echo "ðŸ“ CÃ³digo novo detectado (Assinatura nova ou inexistente)."
          echo "   Prosseguindo com a publicaÃ§Ã£o..."
          echo "skip=false" >> "$GITHUB_OUTPUT"
       fi
       echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 3: PUBLISH (Branch & PR)
    # ------------------------------------------------------------------
    - id: publish
      if: steps.circuit_breaker.outputs.skip != 'true' && steps.idempotency.outputs.skip != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        REPORT_FILE: ${{ inputs.report_file }}
        HEAD_REF: ${{ github.head_ref }}
        PR_NUM: ${{ github.event.pull_request.number }}
        PREFIX: ${{ inputs.report_branch_prefix }}
        TITLE: ${{ inputs.pr_title }}
        BODY: ${{ inputs.pr_body }}
      run: |
        echo "::group::ðŸš€ Publishing Report"
        
        # Nome da Branch: prefixo/branch-origem
        # Ex: audit/report/feature-login
        REPORT_BRANCH="${PREFIX}/${HEAD_REF}"
        
        # Git Ops
        git checkout "$HEAD_REF"
        git checkout -B "$REPORT_BRANCH"
        
        git add "$REPORT_FILE"
        git commit -m "docs: automated report update [skip ci]"
        
        git push -f origin "$REPORT_BRANCH"
        
        # PR Ops
        echo "ðŸ“¡ Managing Pull Request..."
        gh pr create \
          --base "$HEAD_REF" \
          --head "$REPORT_BRANCH" \
          --title "$TITLE" \
          --body "$BODY" || true
          
        PR_URL=$(gh pr view "$REPORT_BRANCH" --json url -q .url)
        echo "âœ… PR Link: $PR_URL"
        
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "status=PUBLISHED" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 4: CONTROLLER OUTPUT
    # Consolida os status dos steps anteriores
    # ------------------------------------------------------------------
    - id: logic_controller
      shell: bash
      if: always()
      env:
        S1: ${{ steps.circuit_breaker.outputs.reason }}
        S2: ${{ steps.idempotency.outputs.reason }}
        S3: ${{ steps.publish.outputs.status }}
      run: |
        FINAL_STATUS="UNKNOWN"
        if [ -n "$S3" ]; then FINAL_STATUS="$S3";
        elif [ -n "$S2" ]; then FINAL_STATUS="$S2";
        elif [ -n "$S1" ]; then FINAL_STATUS="$S1";
        fi
        echo "status=$FINAL_STATUS" >> "$GITHUB_OUTPUT"
