# Malnati/git-report-ops@v1.3.46
name: "Git Pull Request Ops"
description: "Engine de auditoria que assina o conte√∫do, detecta renames e envia notifica√ß√µes padronizadas para Pull Requests."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  pr_number:
    description: "N√∫mero da Pull Request origem, se ser√° usada para descobrir qual √© a branch destino da nova PR."
    required: true
  attached_file_path:
    description: "Arquivo anexo ao reposit√≥rio. (report.csv)"
    required: true
  branch_convention_prefix:
    required: false
    default: "ops/files"
  pr_title:
    required: false
    default: "üõ°Ô∏è Automated Pull Request"
  pr_template_path:
    required: true
    description: "Arquivo anexo ao reposit√≥rio. (pr-template.md)"
  timeline_template_path:
    required: true
    description: "Arquivo anexo ao reposit√≥rio. (timeline-template.md)"
  bot_name:
    description: "Nome do bot usado nos commits."
    required: false
    default: "git-pr-ops-bot"
  bot_email:
    required: false
    default: "git-pr-ops@users.noreply.github.com"
    
runs:
  using: "composite"
  steps:
    - id: step_validate_inputs
      name: "üîß Setup & Input Validation"
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        CALLER_ID: ${{ inputs.caller_id }}
        BRANCH_CONVENTION_PREFIX: ${{ inputs.branch_convention_prefix }}
        PR_TITLE: ${{ inputs.pr_title }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        PR_TEMPLATE_PATH: ${{ inputs.pr_template_path }}
        TIMELINE_TEMPLATE_PATH: ${{ inputs.timeline_template_path }}
      run: |
        echo "::group::üîß Setup & Input Validation"

        if [ -z "$TOKEN" ]; then
          echo "‚ùå [token] Obrigat√≥rio e n√£o informado. Sem este token a Action n√£o consegue chamar a API do GitHub (gh CLI, cria√ß√£o/edi√ß√£o de PR e coment√°rios)."
          echo "   ‚ûú Defina 'token' com 'secrets.GITHUB_TOKEN' ou um PAT com permiss√µes de leitura/escrita em PRs."
          exit 1
        else
          echo "‚úÖ [token] Informado. A Action poder√° criar/atualizar PRs e publicar coment√°rios."
        fi
        
        if [ -z "$PR_NUMBER" ]; then
          echo "‚ùå [pr_number] Obrigat√≥rio e n√£o informado. Sem este pr_number a Action n√£o consegue descobrir qual √© a branch destino da nova PR."
          echo "   ‚ûú Defina 'pr_number' com 'N' ou '#N' da PR origem."
          exit 1
        else
          echo "‚úÖ [pr_number] Informado. A Action descobrir√° dinamicamente qual √© a branch destino da nova PR."
        fi

        if [ -z "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] Caminho n√£o informado. A Action precisa de um arquivo para anexar ao PR."
          echo "   ‚ûú Gere o relat√≥rio no job anterior e passe o caminho em 'attached_file_path' (ex.: 'reports/pmd-report.md')."
          exit 1
        elif [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] Arquivo '$ATTACHED_FILE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'attached_file_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [attached_file_path] Encontrado em '$ATTACHED_FILE_PATH'. Ser√° usado como base do arquivo publicado."
        fi

        if [ -z "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå  [pr_template_path] N√£o informado."
          echo "   ‚ûú Defina 'pr_template_path' com o caminho de um template customizado para personalizar o corpo do PR."
          exit 1
        elif [ ! -f "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå [pr_template_path] Arquivo '$PR_TEMPLATE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'attached_file_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [pr_template_path] Encontrado em '$PR_TEMPLATE_PATH'. Ser√° usado para exibir a descri√ß√£o da Pull Request."
        fi

        if [ -z "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå  [timeline_template_path] N√£o informado."
          echo "   ‚ûú Defina 'timeline_template_path' com o caminho de um template customizado para personalizar a mensqgem do timeline na PR."
          exit 1
        elif [ ! -f "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå [timeline_template_path] Arquivo '$TIMELINE_TEMPLATE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'timeline_template_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [timeline_template_path] Encontrado em '$TIMELINE_TEMPLATE_PATH'. Ser√° usado para exibir a mensagem no timeline da Pull Request."
        fi

        if [ -z "$BRANCH_CONVENTION_PREFIX" ]; then
          echo "‚ÑπÔ∏è [branch_convention_prefix] N√£o informado. Branches de relat√≥rio ser√£o criados sem prefixo dedicado, podendo conflitar com branches de desenvolvimento."
          echo "   ‚ûú Defina um prefixo para isolar branches de relat√≥rio: '<prefix>/<branch_origem>'."
        else
          echo "‚ÑπÔ∏è [branch_convention_prefix] Usando prefixo: '<prefix>/<sufixo_commit>'."
          echo "   ‚ûú Os branches de relat√≥rio ser√£o criados como '<prefix>/<sufixo_commit>'."
        fi

        if [ -z "$PR_TITLE" ]; then
          echo "‚ÑπÔ∏è [pr_title] N√£o informado. O PR poder√° ser criado sem t√≠tulo claro, dificultando a leitura na lista de PRs."
          echo "   ‚ûú Defina 'pr_title' com um t√≠tulo descritivo (ex.: 'üõ°Ô∏è Automated Pull Request')."
        else
          echo "‚ÑπÔ∏è [pr_title] T√≠tulo configurado como: '$PR_TITLE'."
          echo "   ‚ûú Este valor ser√° usado como t√≠tulo dos PRs de relat√≥rio."
        fi

        if [ -z "$BOT_EMAIL" ]; then
          echo "‚ÑπÔ∏è [bot_email] N√£o informado. O git usar√° o email padr√£o do ambiente e isso pode quebrar a prote√ß√£o de loop baseada no autor."
          echo "   ‚ûú Defina 'bot_email' (ex.: 'git-pr-ops@users.noreply.github.com') para: "
          echo "      - identificar os commits do bot; "
          echo "      - permitir que o circuito anti-loop funcione corretamente."
        else
          echo "‚ÑπÔ∏è [bot_email] Usando: '$BOT_EMAIL'."
          echo "   ‚ûú Este email ser√° configurado como autor dos commits e usado na verifica√ß√£o de loops."
        fi
        
        echo "‚úÖ Input validation complete."
        echo "::endgroup::"
      
    - id: pr_info
      name: "üîç Obter informa√ß√µes da PR de origem"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        PR_NUMBER: ${{ inputs.pr_number }}
      run: |
        set -euo pipefail
    
        gh auth status || gh auth login --with-token <<<"$GH_TOKEN"
    
        PR_JSON=$(gh pr view "$PR_NUMBER" --json url,title,headRefName,headRefOid,baseRefName,baseRefOid)
    
        PR_URL=$(echo "$PR_JSON" | jq -r '.url')
        PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')
    
        DEST_BRANCH_NAME=$(echo "$PR_JSON" | jq -r '.baseRefName')
        DEST_BRANCH_SHA=$(echo "$PR_JSON" | jq -r '.baseRefOid')
    
        SOURCE_BRANCH_NAME=$(echo "$PR_JSON" | jq -r '.headRefName')
        SOURCE_BRANCH_SHA=$(echo "$PR_JSON" | jq -r '.headRefOid')
    
        echo "PR_URL=$PR_URL"
        echo "PR_TITLE=$PR_TITLE"
        echo "DEST_BRANCH_NAME=$DEST_BRANCH_NAME"
        echo "DEST_BRANCH_SHA=$DEST_BRANCH_SHA"
        echo "SOURCE_BRANCH_NAME=$SOURCE_BRANCH_NAME"
        echo "SOURCE_BRANCH_SHA=$SOURCE_BRANCH_SHA"
    
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "pr_title=$PR_TITLE" >> "$GITHUB_OUTPUT"
        echo "dest_branch_name=$DEST_BRANCH_NAME" >> "$GITHUB_OUTPUT"
        echo "dest_branch_sha=$DEST_BRANCH_SHA" >> "$GITHUB_OUTPUT"
        echo "source_branch_name=$SOURCE_BRANCH_NAME" >> "$GITHUB_OUTPUT"
        echo "source_branch_sha=$SOURCE_BRANCH_SHA" >> "$GITHUB_OUTPUT"

    - name: "üîÅ Encontrar PRs derivadas"
      id: derivated_prs_finder
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        SOURCE_BRANCH: ${{ steps.pr_info.outputs.source_branch_name }}
      run: |
        set -euo pipefail
    
        gh auth status || gh auth login --with-token <<<"$GH_TOKEN"
    
        if [ -z "$SOURCE_BRANCH" ]; then
          echo "‚ö† SOURCE_BRANCH vazio. Nada a fazer."
          exit 0
        fi
    
        PR_LIST=$(gh pr list \
          --state open \
          --base "$SOURCE_BRANCH" \
          --json number,url,headRefName,baseRefName)
    
        COUNT=$(echo "$PR_LIST" | jq 'length')
    
        echo "üîç PRs derivadas abertas com destino em '$SOURCE_BRANCH': total=$COUNT"
    
        echo "$PR_LIST" | jq -c '.[]' | while read -r pr; do
          NUM=$(echo "$pr" | jq -r '.number')
          URL=$(echo "$pr" | jq -r '.url')
          HEAD=$(echo "$pr" | jq -r '.headRefName')
          BASE=$(echo "$pr" | jq -r '.baseRefName')
    
          echo "- #$NUM $URL"
          echo "  head: $HEAD"
          echo "  base: $BASE"
        done
    
        echo "derived_count=$COUNT" >> "$GITHUB_OUTPUT"
        echo "derived_prs_json=$PR_LIST" >> "$GITHUB_OUTPUT"
    
    - id: branch_convention
      name: "ü™æ Branch Convention"
      shell: bash
      env:
        BRANCH_CONVENTION_PREFIX: ${{ inputs.branch_convention_prefix }}
      run: |
        set -euo pipefail
        echo "::group::ü™æ Define branch convention"
    
        if [ -z "${BRANCH_CONVENTION_PREFIX:-}" ]; then
          BRANCH_CONVENTION_PREFIX="ops/report/latest"
        fi
    
        git fetch --all --prune
    
        LATEST_SHA="$(git rev-parse HEAD)"
        CUSTOM_SUFFIX="${LATEST_SHA: -10}"
    
        BRANCH_CONVENTION="${BRANCH_CONVENTION_PREFIX}/${CUSTOM_SUFFIX}"
    
        echo "prefix: $BRANCH_CONVENTION_PREFIX"
        echo "latest_sha: $LATEST_SHA"
        echo "custom_suffix: $CUSTOM_SUFFIX"
        echo "branch_convention: $BRANCH_CONVENTION"
    
        echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"
        
    - id: commit_attached_file
      name: "üìù Commit File"
      shell: bash
      env:
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        BOT_NAME: ${{ inputs.bot_name }}
      run: |
        set -euo pipefail
        echo "::group::üìù Commit file"
        echo "branch_convention: $BRANCH_CONVENTION"
        echo "attached_file_path: $ATTACHED_FILE_PATH"

        if [ -z "${BRANCH_CONVENTION:-}" ]; then
          echo "‚ùå BRANCH_CONVENTION vazio. Verifique o bloco branch_convention."
          echo "::endgroup::"
          exit 1
        fi

        git fetch --all --prune

        if git show-ref --verify --quiet "refs/heads/$BRANCH_CONVENTION"; then
          echo "‚Ñπ Branch j√° existe localmente: $BRANCH_CONVENTION"
          git checkout "$BRANCH_CONVENTION"
        else
          if git ls-remote --exit-code --heads origin "$BRANCH_CONVENTION" >/dev/null 2>&1; then
            echo "‚Ñπ Branch existe no remoto, criando tracking local: $BRANCH_CONVENTION"
            git checkout -b "$BRANCH_CONVENTION" "origin/$BRANCH_CONVENTION"
          else
            echo "üÜï Criando nova branch a partir do HEAD atual: $BRANCH_CONVENTION"
            git checkout -b "$BRANCH_CONVENTION"
          fi
        fi

        if [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå Arquivo de relat√≥rio n√£o encontrado: $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 1
        fi

        git config user.email "$BOT_EMAIL"
        if [ -n "${BOT_NAME:-}" ]; then
          git config user.name "$BOT_NAME"
        fi

        git add "$ATTACHED_FILE_PATH"

        if git diff --cached --quiet; then
          echo "‚ö†Ô∏è Nenhuma altera√ß√£o para commitar em $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 0
        fi

        git commit -m "chore(attach): update attached file"
        git push origin "$BRANCH_CONVENTION"

        COMMIT_SHA="$(git rev-parse HEAD)"
        echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"
        echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
        echo "‚úÖ Attached file commit realizado em $BRANCH_CONVENTION (commit $COMMIT_SHA)"
        echo "::endgroup::"

    - name: "ü™Ñ Exportar vari√°veis para o PR template"
      id: export_vars_pr_template
      shell: bash
      run: |
        set -euo pipefail
        env | grep -v '^GITHUB_' | while IFS='=' read -r key value; do
          printf '%s=%s\n' "$key" "$value"
          printf '%s=%s\n' "$key" "$value" >> "$GITHUB_ENV"
        done
          
    - name: "üìÑ Render PR template"
      id: render_pr
      uses: Malnati/template-render@v1.0.1
      with:
        template: ${{ inputs.pr_template_path }}
        output: /tmp/hardcode-pr.md
        
    - id: publish_pr
      name: "üöÄ Publishing Pull Request"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        BASE_BRANCH: ${{ steps.pr_info.outputs.source_branch_name }}
        HEAD_BRANCH: ${{ steps.commit_attached_file.outputs.branch_convention }}
        TITLE: ${{ inputs.pr_title }}
        PR_TEMPLATE_PATH: ${{ steps.render_pr.outputs.path }}
      run: |
        set -euo pipefail
        echo "BASE_BRANCH: $BASE_BRANCH"
        echo "HEAD_BRANCH: $HEAD_BRANCH"
        echo "PR_TEMPLATE_PATH: $PR_TEMPLATE_PATH"

        if [ -z "${BASE_BRANCH:-}" ] || [ -z "${HEAD_BRANCH:-}" ]; then
          echo "‚ùå BASE_BRANCH ou HEAD_BRANCH vazios. Verifique pr_info e commit_attached_file."
          echo "::endgroup::"
          exit 1
        fi

        gh auth status || gh auth login --with-token <<<"$GH_TOKEN"

        gh pr create \
          --base "$BASE_BRANCH" \
          --head "$HEAD_BRANCH" \
          --title "$TITLE" \
          --body-file "$PR_TEMPLATE_PATH"

        PR_URL="$(gh pr view "$HEAD_BRANCH" --json url --jq '.url' || echo "")"

        if [ -z "$PR_URL" ] || [ "$PR_URL" = "null" ]; then
          echo "üî¥ Falha ao obter URL da PR rec√©m-criada." >&2
          echo "::endgroup::"
          exit 1
        fi

        echo "PR_URL: $PR_URL"
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "pr_state=OPEN" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    - name: "ü™Ñ Exportar vari√°veis para o template"
      id: export_vars_timeline_template
      shell: bash
      run: |
        set -euo pipefail
        env | grep -v '^GITHUB_' | while IFS='=' read -r key value; do
          printf '%s=%s\n' "$key" "$value"
          printf '%s=%s\n' "$key" "$value" >> "$GITHUB_ENV"
        done
          
    - name: "üìÑ Render timeline template"
      id: render_timeline
      uses: Malnati/template-render@v1.0.1
      with:
        template: ${{ inputs.timeline_template_path }}
        output: /tmp/hardcode-timeline.md
          
    - id: timeline_notification
      name: "üîî Notify over PR Timeline"
      uses: Malnati/pr-comment@v8.0.2
      with:
        token: ${{ inputs.token }}
        pr_number: ${{ inputs.pr_number }}
        template_path: ${{ steps.render_timeline.outputs.path }}
