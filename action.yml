# Malnati/git-report-ops@v1.3.26
name: "Git Pull Request Ops"
description: "Engine de auditoria que assina o conte√∫do, detecta renames e envia notifica√ß√µes padronizadas para Pull Requests."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  attached_file_path:
    description: "Arquivo anexo ao reposit√≥rio. (report.csv)"
    required: true
  branch_convention_prefix:
    required: false
    default: "ops/files"
  pr_title:
    required: false
    default: "üõ°Ô∏è Automated Pull Request"
  bot_email:
    required: false
    default: "git-pr-ops@users.noreply.github.com"
  pr_template_path:
    required: true
    description: "Arquivo anexo ao reposit√≥rio. (pr-template.md)"
  timeline_template_path:
    required: true
    description: "Arquivo anexo ao reposit√≥rio. (timeline-template.md)"
    
runs:
  using: "composite"
  steps:
    - id: step_validate_inputs
      name: "üîß Setup & Input Validation"
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        CALLER_ID: ${{ inputs.caller_id }}
        BRANCH_CONVENTION_PREFIX: ${{ inputs.branch_convention_prefix }}
        PR_TITLE: ${{ inputs.pr_title }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        PR_TEMPLATE_PATH: ${{ inputs.pr_template_path }}
        TIMELINE_TEMPLATE_PATH: ${{ inputs.timeline_template_path }}

      run: |
        echo "::group::üîß Setup & Input Validation"

        # token (obrigat√≥rio)
        if [ -z "$TOKEN" ]; then
          echo "‚ùå [token] Obrigat√≥rio e n√£o informado. Sem este token a Action n√£o consegue chamar a API do GitHub (gh CLI, cria√ß√£o/edi√ß√£o de PR e coment√°rios)."
          echo "   ‚ûú Defina 'token' com 'secrets.GITHUB_TOKEN' ou um PAT com permiss√µes de leitura/escrita em PRs."
          exit 1
        else
          echo "‚úÖ [token] Informado. A Action poder√° criar/atualizar PRs e publicar coment√°rios."
        fi

        # attached_file_path (obrigat√≥rio)
        if [ -z "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] Caminho n√£o informado. A Action precisa de um arquivo para anexar ao PR."
          echo "   ‚ûú Gere o relat√≥rio no job anterior e passe o caminho em 'attached_file_path' (ex.: 'reports/pmd-report.md')."
          exit 1
        elif [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] Arquivo '$ATTACHED_FILE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'attached_file_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [attached_file_path] Encontrado em '$ATTACHED_FILE_PATH'. Ser√° usado como base do arquivo publicado."
        fi

        # pr_template_path (obrigat√≥rio)
        if [ -z "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå  [pr_template_path] N√£o informado."
          echo "   ‚ûú Defina 'pr_template_path' com o caminho de um template customizado para personalizar o corpo do PR."
          exit 1
        elif [ ! -f "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå [pr_template_path] Arquivo '$PR_TEMPLATE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'attached_file_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [pr_template_path] Encontrado em '$PR_TEMPLATE_PATH'. Ser√° usado para exibir a descri√ß√£o da Pull Request."
        fi

        # timeline_template_path (obrigat√≥rio)
        if [ -z "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå  [timeline_template_path] N√£o informado."
          echo "   ‚ûú Defina 'timeline_template_path' com o caminho de um template customizado para personalizar a mensqgem do timeline na PR."
          exit 1
        elif [ ! -f "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå [timeline_template_path] Arquivo '$TIMELINE_TEMPLATE_PATH' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'timeline_template_path' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [timeline_template_path] Encontrado em '$TIMELINE_TEMPLATE_PATH'. Ser√° usado para exibir a mensagem no timeline da Pull Request."
        fi
        
        # branch_convention_prefix (opcional)
        if [ -z "$BRANCH_CONVENTION_PREFIX" ]; then
          echo "‚ÑπÔ∏è [branch_convention_prefix] N√£o informado. Branches de relat√≥rio ser√£o criados sem prefixo dedicado, podendo conflitar com branches de desenvolvimento."
          echo "   ‚ûú Defina um prefixo (ex.: 'audit/report') para isolar branches de relat√≥rio: '<prefix>/<branch_origem>'."
        else
          echo "‚ÑπÔ∏è [branch_convention_prefix] Usando prefixo: '$BRANCH_CONVENTION_PREFIX'."
          echo "   ‚ûú Os branches de relat√≥rio ser√£o criados como '${BRANCH_CONVENTION_PREFIX}/<branch_de_origem>'."
        fi

        # pr_title (opcional)
        if [ -z "$PR_TITLE" ]; then
          echo "‚ÑπÔ∏è [pr_title] N√£o informado. O PR poder√° ser criado sem t√≠tulo claro, dificultando a leitura na lista de PRs."
          echo "   ‚ûú Defina 'pr_title' com um t√≠tulo descritivo (ex.: 'üõ°Ô∏è Automated Pull Request')."
        else
          echo "‚ÑπÔ∏è [pr_title] T√≠tulo configurado como: '$PR_TITLE'."
          echo "   ‚ûú Este valor ser√° usado como t√≠tulo dos PRs de relat√≥rio."
        fi

        # bot_email (opcional, mas cr√≠tico para loop protection)
        if [ -z "$BOT_EMAIL" ]; then
          echo "‚ÑπÔ∏è [bot_email] N√£o informado. O git usar√° o email padr√£o do ambiente e isso pode quebrar a prote√ß√£o de loop baseada no autor."
          echo "   ‚ûú Defina 'bot_email' (ex.: 'git-pr-ops@users.noreply.github.com') para: "
          echo "      - identificar os commits do bot; "
          echo "      - permitir que o circuito anti-loop funcione corretamente."
        else
          echo "‚ÑπÔ∏è [bot_email] Usando: '$BOT_EMAIL'."
          echo "   ‚ûú Este email ser√° configurado como autor dos commits e usado na verifica√ß√£o de loops."
        fi
        git config user.name "git-pr-ops-bot"
        git config user.email "$BOT_EMAIL"

        echo "‚úÖ Input validation complete."
        echo "::endgroup::"

    - id: branch_convention
      name: "ü™æ Branch Convention"
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
      run: |
        echo "::group::ü™æ Create branch due to it does not exist yet;"
        echo "head_ref: $HEAD_REF"
        git fetch --all --prune
        LATEST_SHA="$(git rev-list --all -n 1)"
        CUSTOM_SUFFIX="${LATEST_SHA: -10}"
        PREFIX="ops/latest/${CUSTOM_SUFFIX}"
        echo "latest_sha: $LATEST_SHA"
        echo "custom_suffix: $CUSTOM_SUFFIX"
        echo "branch_convention_prefix: $PREFIX"
        BRANCH_CONVENTION="${PREFIX}/${HEAD_REF}"
        echo "branch_convention: $BRANCH_CONVENTION"
        if [ "$HEAD_REF" = "$BRANCH_CONVENTION" ]; then
          echo "‚úÖ J√° est√° na pr√≥pria branch: $BRANCH_CONVENTION. Nada a fazer."
          echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
          exit 0
        fi
        if git show-ref --verify --quiet "refs/heads/$BRANCH_CONVENTION"; then
          echo "‚ö†Ô∏è Branch j√° existe: $BRANCH_CONVENTION"
        else
          git checkout "$HEAD_REF"
          git checkout -b "$BRANCH_CONVENTION"
          echo "‚úÖ Branch criada: $BRANCH_CONVENTION"
        fi
        echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    - id: latest_commit_verify
      name: "üîé Latest Commit Verify"
      shell: bash
      env:
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üîé Verify latest commit owner and branch"
        git fetch --all --prune
        LATEST_SHA="$(git rev-list --all -n 1)"
        CURRENT_SHA="$(git rev-parse HEAD)"
        CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        COMMIT_AUTHOR_RAW="$(git show -s --format='%an|%ae' "$LATEST_SHA")"
        COMMIT_AUTHOR_NAME="${COMMIT_AUTHOR_RAW%%|*}"
        COMMIT_AUTHOR_EMAIL="${COMMIT_AUTHOR_RAW##*|}"
        echo "latest_sha: $LATEST_SHA"
        echo "current_sha: $CURRENT_SHA"
        echo "current_branch: $CURRENT_BRANCH"
        echo "commit_author_name: $COMMIT_AUTHOR_NAME"
        echo "commit_author_email: $COMMIT_AUTHOR_EMAIL"
        echo "bot_email: $BOT_EMAIL"
        is_bot_commit=false
        if [ "$COMMIT_AUTHOR_EMAIL" = "$BOT_EMAIL" ]; then
          is_bot_commit=true
        fi
        is_latest_on_current_branch=false
        if [ "$LATEST_SHA" = "$CURRENT_SHA" ]; then
          is_latest_on_current_branch=true
        fi
        if [ "$is_bot_commit" = true ] && [ "$is_latest_on_current_branch" = true ]; then
          echo "‚úÖ √öltimo commit do reposit√≥rio j√° √© do bot nesta mesma branch. Nada a fazer."
          echo "::endgroup::"
          exit 0
        fi
        echo "::endgroup::"

    - id: commit_attached_file
      name: "üìù Commit File"
      shell: bash
      env:
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        BOT_NAME: ${{ inputs.bot_name }}
      run: |
        echo "::group::üìù Commit file"
        echo "branch_convention: $BRANCH_CONVENTION"
        echo "attached_file_path: $ATTACHED_FILE_PATH"
        git checkout "$BRANCH_CONVENTION"
        if [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå Arquivo de relat√≥rio n√£o encontrado: $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 1
        fi
        git config user.email "$BOT_EMAIL"
        if [ -n "${BOT_NAME:-}" ]; then
          git config user.name "$BOT_NAME"
        fi
        git add "$ATTACHED_FILE_PATH"
        if git diff --cached --quiet; then
          echo "‚ö†Ô∏è Nenhuma altera√ß√£o para commitar em $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 0
        fi
        git commit -m "chore(attach): update attached file"
        git push origin "$BRANCH_CONVENTION"
        COMMIT_SHA="$(git rev-parse HEAD)"
        echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"
        echo "‚úÖ Attached file commit realizado em $BRANCH_CONVENTION (commit $COMMIT_SHA)"
        echo "::endgroup::"

    - id: analyze_pr_status
      name: "üîç An√°lise de PR Existente"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        COMMIT_SHA: ${{ steps.commit_attached_file.outputs.commit_sha }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
        HEAD_REF: ${{ github.head_ref }}
      run: |
        echo "::group::üîç Analyzing Existing PR"
        echo "BRANCH_CONVENTION: $BRANCH_CONVENTION"
        echo "HEAD_REF: $HEAD_REF"

        PR_DATA=$(gh pr list --base "$HEAD_REF" --state all --json headRefName,state,url,mergedAt)
        echo "PR_DATA raw: $PR_DATA"

        echo "Listing PR entries:"
        echo "$PR_DATA" | jq -r '.[] | " - headRefName=\(.headRefName) state=\(.state) url=\(.url) mergedAt=\(.mergedAt)"'

        FILTERED=$(echo "$PR_DATA" | jq -r '.[] | select(.headRefName | startswith("ops/latest/")) | @base64')
        echo "Filtered candidates (base64):"
        echo "$FILTERED" | nl -ba

        BEST=""
        BEST_PRIORITY=99

        while IFS= read -r CAND; do
          if [ -z "$CAND" ]; then
            continue
          fi

          DECODED=$(echo "$CAND" | base64 --decode)
          STATE=$(echo "$DECODED" | jq -r '.state')
          URL=$(echo "$DECODED" | jq -r '.url')
          HEAD=$(echo "$DECODED" | jq -r '.headRefName')
          MERGED=$(echo "$DECODED" | jq -r '.mergedAt')

          if [ "$STATE" = "OPEN" ]; then
            PRIORITY=0
          elif [ "$STATE" = "CLOSED" ] && [ "$MERGED" = "null" ]; then
            PRIORITY=1
          else
            PRIORITY=2
          fi

          echo "Candidate: head=$HEAD state=$STATE merged=$MERGED priority=$PRIORITY"

          if [ "$PRIORITY" -lt "$BEST_PRIORITY" ]; then
            BEST_PRIORITY=$PRIORITY
            BEST="$CAND"
          fi
        done <<< "$FILTERED"

        EXISTING="$BEST"
        echo "EXISTING (base64): $EXISTING"

        if [ -z "$EXISTING" ]; then
          echo "‚ö†Ô∏è No existing audit PR for this base branch."
          echo "status_code=NOT_FOUND" >> "$GITHUB_OUTPUT"
        else
          decode() { echo "$EXISTING" | base64 --decode; }
          STATE=$(decode | jq -r '.state')
          URL=$(decode | jq -r '.url')
          HEAD=$(decode | jq -r '.headRefName')
          MERGED=$(decode | jq -r '.mergedAt')

          echo "existing_head: $HEAD"
          echo "state: $STATE"
          echo "url: $URL"
          echo "merged: $MERGED"

          echo "existing_url=$URL" >> "$GITHUB_OUTPUT"
          echo "existing_head=$HEAD" >> "$GITHUB_OUTPUT"
          echo "pr_state=$STATE" >> "$GITHUB_OUTPUT"

          if [ "$STATE" = "OPEN" ]; then
            echo "üü¢ PR is OPEN."
            echo "status_code=OPEN_EXISTING" >> "$GITHUB_OUTPUT"
          elif [ "$STATE" = "CLOSED" ] && [ "$MERGED" = "null" ]; then
            echo "üî¥ PR is CLOSED (Unmerged)."
            echo "status_code=CLOSED_UNMERGED" >> "$GITHUB_OUTPUT"
          else
            echo "‚ö™ PR is Merged/Missing."
            echo "status_code=PREVIOUSLY_MERGED" >> "$GITHUB_OUTPUT"
          fi
        fi

        echo "::endgroup::"

    - id: publish_pr
      name: "üöÄ Publishing/Updating Pull Request"
      if: ${{ steps.analyze_pr_status.outputs.status_code != 'PREVIOUSLY_MERGED' && steps.analyze_pr_status.outputs.status_code != 'CLOSED_UNMERGED' }}
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        HEAD_REF: ${{ github.head_ref }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
        TITLE: ${{ inputs.pr_title }}
        PR_TEMPLATE_PATH: ${{ inputs.pr_template_path }}
        STATUS_CODE: ${{ steps.analyze_pr_status.outputs.status_code }}
        EXISTING_URL: ${{ steps.analyze_pr_status.outputs.existing_url }}
        EXISTING_HEAD: ${{ steps.analyze_pr_status.outputs.existing_head }}
      run: |
        echo "::group::üöÄ Publishing"
        echo "STATUS_CODE: $STATUS_CODE"
        echo "HEAD_REF: $HEAD_REF"
        echo "BRANCH_CONVENTION: $BRANCH_CONVENTION"
        echo "PR_TEMPLATE_PATH: $PR_TEMPLATE_PATH"

        if [ "$STATUS_CODE" = "NOT_FOUND" ]; then
          echo "üîπ Nenhuma PR anterior encontrada. Criando nova PR..."
          if gh pr create --base "$HEAD_REF" --head "$BRANCH_CONVENTION" --title "$TITLE" --body-file "$PR_TEMPLATE_PATH"; then
            echo "‚úÖ New PR created."
          else
            echo "üî¥ Falha ao criar nova PR." >&2
            exit 1
          fi
        elif [ "$STATUS_CODE" = "OPEN_EXISTING" ]; then
          echo "üîπ PR existente aberta encontrada. Atualizando PR..."
          echo "EXISTING_HEAD: $EXISTING_HEAD"
          echo "EXISTING_URL:  $EXISTING_URL"

          PR_URL="$EXISTING_URL"
          echo "PR_URL: $PR_URL"

          if ! gh pr edit "$PR_URL" --body-file "$PR_TEMPLATE_PATH"; then
            echo "üî¥ Erro ao atualizar PR em $PR_URL com o arquivo $PR_TEMPLATE_PATH" >&2
            exit 1
          fi
          echo "pr_url: $PR_URL"
        else
          echo "‚ÑπÔ∏è STATUS_CODE=$STATUS_CODE n√£o requer create/edit."
        fi

        echo "::endgroup::"


    - id: timeline_notification
      name: "üîî Notify over PR Timeline"
      uses: Malnati/pr-comment@v8.0.0
      env:
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        EXISTING_URL: ${{ steps.analyze_pr_status.outputs.existing_url }}
      with:
        token: ${{ inputs.token }}
        template_path: ${{ inputs.timeline_template_path }}
        pr_number: ${{ github.event.pull_request.number }}
        message_id: git-report-ops
        variables: |
            {
              "ATTACHED_FILE_PATH": "${ATTACHED_FILE_PATH}",
              "BRANCH_CONVENTION": "${{ steps.branch_convention.outputs.branch_convention }}",
              "COMMIT_SHA": "${{steps.commit_attached_file.outputs.commit_sha}}",
              "PR_URL": ${EXISTING_URL}
            }
