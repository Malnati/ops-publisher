# Malnati/git-report-ops@v1.3.13
name: "Git Report Ops"
description: "Engine de auditoria que assina o conte√∫do, detecta renames e envia notifica√ß√µes padronizadas para Pull Requests."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  report_file:
    description: "Arquivo Markdown."
    required: true
  caller_id:
    required: false
    default: "unknown-workflow"
  scan_extensions:
    required: false
    default: "ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml"
  scan_exclude:
    required: false
    default: "node_modules|dist|build|.git|.github"
  report_branch_prefix:
    required: false
    default: "audit/report"
  pr_title:
    required: false
    default: "üõ°Ô∏è Automated Audit Report"
  pr_body:
    required: false
    default: "Relat√≥rio de auditoria."
  bot_email:
    required: false
    default: "git-report-ops@users.noreply.github.com"
  pr_template_path:
    required: false
    default: ""
  notification_id:
    required: false
    default: ""

outputs:
  pr_url:
    value: ${{ steps.controller.outputs.pr_url }}
  status:
    value: ${{ steps.controller.outputs.status }}

runs:
  using: "composite"
  steps:

    - name: "üîß Setup & Input Validation"
    - id: step_validate_inputs
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPORT: ${{ inputs.report_file }}
        CALLER_ID: ${{ inputs.caller_id }}
        SCAN_EXTENSIONS: ${{ inputs.scan_extensions }}
        SCAN_EXCLUDE: ${{ inputs.scan_exclude }}
        REPORT_BRANCH_PREFIX: ${{ inputs.report_branch_prefix }}
        PR_TITLE: ${{ inputs.pr_title }}
        PR_BODY: ${{ inputs.pr_body }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        PR_TEMPLATE_PATH: ${{ inputs.pr_template_path }}
        NOTIFICATION_ID: ${{ inputs.notification_id }}
      run: |
        echo "::group::üîß Setup & Input Validation"

        # token (obrigat√≥rio)
        if [ -z "$TOKEN" ]; then
          echo "‚ùå [token] Obrigat√≥rio e n√£o informado. Sem este token a Action n√£o consegue chamar a API do GitHub (gh CLI, cria√ß√£o/edi√ß√£o de PR e coment√°rios)."
          echo "   ‚ûú Defina 'token' com 'secrets.GITHUB_TOKEN' ou um PAT com permiss√µes de leitura/escrita em PRs."
          exit 1
        else
          echo "‚úÖ [token] Informado. A Action poder√° criar/atualizar PRs e publicar coment√°rios."
        fi

        # report_file (obrigat√≥rio)
        if [ -z "$REPORT" ]; then
          echo "‚ùå [report_file] Caminho n√£o informado. A Action precisa de um arquivo Markdown para anexar ao PR."
          echo "   ‚ûú Gere o relat√≥rio no job anterior e passe o caminho em 'report_file' (ex.: 'reports/pmd-report.md')."
          exit 1
        elif [ ! -f "$REPORT" ]; then
          echo "‚ùå [report_file] Arquivo '$REPORT' n√£o encontrado."
          echo "   ‚ûú Verifique o caminho informado em 'report_file' e garanta que o arquivo √© criado antes desta Action."
          exit 1
        else
          echo "‚úÖ [report_file] Encontrado em '$REPORT'. Ser√° usado como base do relat√≥rio publicado."
        fi

        # caller_id (opcional)
        if [ -z "$CALLER_ID" ] || [ "$CALLER_ID" = "unknown-workflow" ]; then
          echo "‚ÑπÔ∏è [caller_id] N√£o informado. Ser√° usado 'unknown-workflow' como identificador do workflow de origem."
          echo "   ‚ûú Defina 'caller_id' (ex.: 'pmd-audit', 'eslint-audit') para rastrear qual workflow/job gerou o relat√≥rio."
        else
          echo "‚úÖ [caller_id] Definido como '$CALLER_ID'. Ser√° inclu√≠do na assinatura/meta do relat√≥rio e nas notifica√ß√µes."
        fi

        # scan_extensions (opcional)
        if [ -z "$SCAN_EXTENSIONS" ]; then
          echo "‚ÑπÔ∏è [scan_extensions] N√£o informado. A assinatura poder√° considerar todos os arquivos, o que pode aumentar o custo da varredura."
          echo "   ‚ûú Recomenda-se definir uma lista como 'ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml' para focar em c√≥digo-fonte."
        else
          echo "‚ÑπÔ∏è [scan_extensions] Usando lista: '$SCAN_EXTENSIONS'."
          echo "   ‚ûú Ajuste 'scan_extensions' para incluir/remover extens√µes que devem impactar a assinatura de conte√∫do."
        fi

        # scan_exclude (opcional)
        if [ -z "$SCAN_EXCLUDE" ]; then
          echo "‚ÑπÔ∏è [scan_exclude] N√£o informado. Nenhum diret√≥rio ser√° exclu√≠do da an√°lise, o que pode deix√°-la mais lenta."
          echo "   ‚ûú Defina 'scan_exclude' (ex.: 'node_modules|dist|build|.git|.github') para ignorar pastas de build/depend√™ncias."
        else
          echo "‚ÑπÔ∏è [scan_exclude] Usando padr√£o de exclus√£o: '$SCAN_EXCLUDE'."
          echo "   ‚ûú Ajuste este valor se quiser incluir ou remover diret√≥rios ignorados na assinatura."
        fi

        # report_branch_prefix (opcional)
        if [ -z "$REPORT_BRANCH_PREFIX" ]; then
          echo "‚ÑπÔ∏è [report_branch_prefix] N√£o informado. Branches de relat√≥rio ser√£o criados sem prefixo dedicado, podendo conflitar com branches de desenvolvimento."
          echo "   ‚ûú Defina um prefixo (ex.: 'audit/report') para isolar branches de relat√≥rio: '<prefix>/<branch_origem>'."
        else
          echo "‚ÑπÔ∏è [report_branch_prefix] Usando prefixo: '$REPORT_BRANCH_PREFIX'."
          echo "   ‚ûú Os branches de relat√≥rio ser√£o criados como '${REPORT_BRANCH_PREFIX}/<branch_de_origem>'."
        fi

        # pr_title (opcional)
        if [ -z "$PR_TITLE" ]; then
          echo "‚ÑπÔ∏è [pr_title] N√£o informado. O PR poder√° ser criado sem t√≠tulo claro, dificultando a leitura na lista de PRs."
          echo "   ‚ûú Defina 'pr_title' com um t√≠tulo descritivo (ex.: 'üõ°Ô∏è Automated Audit Report')."
        else
          echo "‚ÑπÔ∏è [pr_title] T√≠tulo configurado como: '$PR_TITLE'."
          echo "   ‚ûú Este valor ser√° usado como t√≠tulo dos PRs de relat√≥rio."
        fi

        # pr_body (opcional)
        if [ -z "$PR_BODY" ]; then
          echo "‚ÑπÔ∏è [pr_body] N√£o informado. Apenas o conte√∫do gerado pelo template ser√° usado no corpo do PR."
          echo "   ‚ûú Defina 'pr_body' se quiser incluir um texto fixo adicional (ex.: instru√ß√µes para revisores)."
        else
          echo "‚ÑπÔ∏è [pr_body] Texto base informado. Ele ser√° injetado no template do corpo do PR."
        fi

        # bot_email (opcional, mas cr√≠tico para loop protection)
        if [ -z "$BOT_EMAIL" ]; then
          echo "‚ÑπÔ∏è [bot_email] N√£o informado. O git usar√° o email padr√£o do ambiente e isso pode quebrar a prote√ß√£o de loop baseada no autor."
          echo "   ‚ûú Defina 'bot_email' (ex.: 'git-report-ops@users.noreply.github.com') para: "
          echo "      - identificar os commits do bot; "
          echo "      - permitir que o circuito anti-loop funcione corretamente."
        else
          echo "‚ÑπÔ∏è [bot_email] Usando: '$BOT_EMAIL'."
          echo "   ‚ûú Este email ser√° configurado como autor dos commits e usado na verifica√ß√£o de loops."
        fi
        git config user.name "git-report-ops-bot"
        git config user.email "$BOT_EMAIL"

        # pr_template_path (opcional)
        if [ -z "$PR_TEMPLATE_PATH" ]; then
          echo "‚ÑπÔ∏è [pr_template_path] N√£o informado. Ser√° usado o template padr√£o em 'templates/pr-body-report.md'."
          echo "   ‚ûú Defina 'pr_template_path' com o caminho de um template customizado para personalizar o corpo do PR."
        else
          if [ -f "$PR_TEMPLATE_PATH" ]; then
            echo "‚ÑπÔ∏è [pr_template_path] Template customizado encontrado em '$PR_TEMPLATE_PATH'."
            echo "   ‚ûú Ele ser√° usado por 'envsubst' para gerar o corpo do PR."
          else
            echo "‚ö†Ô∏è [pr_template_path] Caminho informado ('$PR_TEMPLATE_PATH'), mas arquivo n√£o existe."
            echo "   ‚ûú O template padr√£o ser√° usado. Verifique o caminho ou inclua o arquivo no reposit√≥rio."
          fi
        fi

        # notification_id (opcional)
        if [ -z "$NOTIFICATION_ID" ]; then
          echo "‚ÑπÔ∏è [notification_id] N√£o informado. Ser√° gerado um identificador derivado de 'caller_id'."
          echo "   ‚ûú Use 'notification_id' se quiser controlar manualmente o agrupamento de coment√°rios (ex.: evitar sobrescrever mensagens entre execu√ß√µes diferentes)."
        else
          echo "‚ÑπÔ∏è [notification_id] Definido como: '$NOTIFICATION_ID'."
          echo "   ‚ûú Este valor ser√° usado como chave de agrupamento para coment√°rios na PR."
        fi

        echo "‚úÖ Input validation complete."
        echo "::endgroup::"

    - name: "‚Ñπ Resolve IDs"
    - id: step_resolve_ids
      shell: bash
      env:
        INPUT_ID: ${{ inputs.notification_id }}
        CALLER: ${{ inputs.caller_id }}
      run: |
        FINAL_ID="git-report-ops-$CALLER";
        if [ -n "$INPUT_ID" ]; 
            then FINAL_ID="$INPUT_ID";       
        fi
        echo "notify_id=$FINAL_ID" >> "$GITHUB_OUTPUT"
        echo "inputs.caller_id: $FINAL_ID"
        echo "‚úÖ notify_id: $FINAL_ID"
        echo "::endgroup::"

    - name: "ü™æ Branch Convention"
    - id: step_branch_convention
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
      run: |
        echo "::group::ü™æ Create branch due to it does not exist yet;"
        echo "head_ref: $HEAD_REF"
        git fetch --all --prune
        LATEST_SHA="$(git rev-list --all -n 1)"
        CUSTOM_SUFFIX="${LATEST_SHA: -10}"
        PREFIX="ops/report/latest/${CUSTOM_SUFFIX}"
        echo "latest_sha: $LATEST_SHA"
        echo "custom_suffix: $CUSTOM_SUFFIX"
        echo "report_branch_prefix: $PREFIX"
        REPORT_BRANCH="${PREFIX}/${HEAD_REF}"
        echo "report_branch: $REPORT_BRANCH"
        if [ "$CURRENT_BRANCH" = "$REPORT_BRANCH" ]; then
          echo "‚úÖ J√° est√° na pr√≥pria report branch: $REPORT_BRANCH. Nada a fazer."
          echo "report_branch=$REPORT_BRANCH" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
          exit 0
        fi
        if git show-ref --verify --quiet "refs/heads/$REPORT_BRANCH"; then
          echo "‚ö†Ô∏è Branch j√° existe: $REPORT_BRANCH"
        else
          git checkout "$HEAD_REF"
          git checkout -b "$REPORT_BRANCH"
          echo "‚úÖ Report branch criada: $REPORT_BRANCH"
        fi
        echo "report_branch=$REPORT_BRANCH" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"
    
        - name: üêõ Notify Branch Convention
          uses: Malnati/pr-comment@v8.0.0
          env:
            BODY_MESSAGE: |
              Branch criada
          with:
            token: ${{ inputs.token }}
            pr_number: ${{ github.event.pull_request.number }}
            use_raw_body: "true"
        
        
    # BLOCK: üîé LATEST COMMIT CANNOT BE BOT
    # Se o ultimo commit do reposit√≥rio for do bot, nesta mesma report_branch n√£o √© necess√°rio continuar
    - id: latest_commit_verify
      shell: bash
      env:
        BOT_EMAIL: ${{ inputs.bot_email }}
      run: |
        echo "::group::üîé Verify latest commit owner and branch"
    
        git fetch --all --prune
    
        LATEST_SHA="$(git rev-list --all -n 1)"
        CURRENT_SHA="$(git rev-parse HEAD)"
        CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
    
        COMMIT_AUTHOR_RAW="$(git show -s --format='%an|%ae' "$LATEST_SHA")"
        COMMIT_AUTHOR_NAME="${COMMIT_AUTHOR_RAW%%|*}"
        COMMIT_AUTHOR_EMAIL="${COMMIT_AUTHOR_RAW##*|}"
    
        echo "latest_sha: $LATEST_SHA"
        echo "current_sha: $CURRENT_SHA"
        echo "current_branch: $CURRENT_BRANCH"
        echo "commit_author_name: $COMMIT_AUTHOR_NAME"
        echo "commit_author_email: $COMMIT_AUTHOR_EMAIL"
        echo "bot_email: $BOT_EMAIL"
    
        is_bot_commit=false
        if [ "$COMMIT_AUTHOR_EMAIL" = "$BOT_EMAIL" ]; then
          is_bot_commit=true
        fi
    
        is_latest_on_current_branch=false
        if [ "$LATEST_SHA" = "$CURRENT_SHA" ]; then
          is_latest_on_current_branch=true
        fi
    
        if [ "$is_bot_commit" = true ] && [ "$is_latest_on_current_branch" = true ]; then
          echo "‚úÖ √öltimo commit do reposit√≥rio j√° √© do bot nesta mesma branch. Nada a fazer."
          echo "::endgroup::"
          exit 0
        fi
        echo "::endgroup::"
    
    # BLOCK: üìù COMMIT REPORT FILE
    # Faz o commit do arquivo informado nesta mesma report_branch 
    - id: commit_report
      shell: bash
      env:
        REPORT: ${{ inputs.report_file }}
        REPORT_BRANCH: ${{ steps.branch_convention.outputs.report_branch }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        BOT_NAME: ${{ inputs.bot_name }}
      run: |
        echo "::group::üìù Commit report file"
    
        echo "report_branch: $REPORT_BRANCH"
        echo "report_file: $REPORT"
    
        git checkout "$REPORT_BRANCH"
    
        if [ ! -f "$REPORT" ]; then
          echo "‚ùå Arquivo de relat√≥rio n√£o encontrado: $REPORT"
          echo "::endgroup::"
          exit 1
        fi
    
        git config user.email "$BOT_EMAIL"
        if [ -n "${BOT_NAME:-}" ]; then
          git config user.name "$BOT_NAME"
        fi
    
        git add "$REPORT"
    
        if git diff --cached --quiet; then
          echo "‚ö†Ô∏è Nenhuma altera√ß√£o para commitar em $REPORT"
          echo "::endgroup::"
          exit 0
        fi
    
        git commit -m "chore(report): update audit report"
        git push origin "$REPORT_BRANCH"
    
        echo "‚úÖ Report commit realizado em $REPORT_BRANCH"
        echo "::endgroup::"

    # 3.2 - An√°lise de PR Existente
    - id: analyze_pr_status
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        COMMIT_SHA: ${{ steps.search_history.outputs.commit_sha }}
        PREFIX: ${{ inputs.report_branch_prefix }}
      run: |
        echo "::group::üîç Analyzing Existing PR"
        BRANCHES=$(git branch -r --contains "$COMMIT_SHA" 2>/dev/null || true)
        echo "BRANCHES:"
        echo "$BRANCHES"
        
        FILTERED=$(printf '%s\n' "$BRANCHES" | grep "$PREFIX" 2>/dev/null || true)
        echo "FILTERED:"
        echo "$FILTERED"
        
        FIRST=$(printf '%s\n' "$FILTERED" | head -n 1 || true)
        echo "FIRST:"
        echo "$FIRST"
        
        STRIPPED=$(printf '%s\n' "$FIRST" | sed 's#origin/##' || true)
        echo "STRIPPED:"
        echo "$STRIPPED"
        
        TARGET=$(printf '%s\n' "$STRIPPED" | xargs || true)
        echo "TARGET: $TARGET"
        
        if [ -n "$TARGET" ]; then
           PR_DATA=$(gh pr list --head "$TARGET" --state all --json state,url,mergedAt --limit 1)
           echo "PR_DATA bruto:"
           echo "$PR_DATA"
           STATE=$(echo "$PR_DATA" | jq -r '.[0].state')
           URL=$(echo "$PR_DATA" | jq -r '.[0].url')
           MERGED=$(echo "$PR_DATA" | jq -r '.[0].mergedAt')
           
           echo "existing_url=$URL" >> "$GITHUB_OUTPUT"
           echo "pr_state=$STATE" >> "$GITHUB_OUTPUT"
           
           if [ "$STATE" == "OPEN" ]; then
              echo "üü¢ PR is OPEN."
              echo "status_code=OPEN_EXISTING" >> "$GITHUB_OUTPUT"
           elif [ "$STATE" == "CLOSED" ] && [ "$MERGED" == "null" ]; then
              echo "üî¥ PR is CLOSED (Unmerged)."
              echo "status_code=CLOSED_UNMERGED" >> "$GITHUB_OUTPUT"
           else
              echo "‚ö™ PR is Merged/Missing."
              echo "status_code=PREVIOUSLY_MERGED" >> "$GITHUB_OUTPUT"
           fi
        else
           echo "‚ö†Ô∏è Branch not found. Treating as new."
           echo "status_code=NOT_FOUND" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # BLOCK 5: PUBLISH
    - id: prepare_files
      if: steps.analyze_pr_status.outputs.status_code == 'NOT_FOUND'
      shell: bash
      env:
        REPORT: ${{ inputs.report_file }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        SIGNATURE: ${{ env.CODE_SIGNATURE }}
        CALLER_ID: ${{ inputs.caller_id }}
        PR_NUM: ${{ github.event.pull_request.number }}
        HEAD_REF: ${{ github.head_ref }}
        USER_BODY: ${{ inputs.pr_body }}
        CUSTOM_TEMPLATE: ${{ inputs.pr_template_path }}
        DEFAULT_TEMPLATE: ${{ github.action_path }}/templates/pr-body-report.md
      run: |
        echo "::group::üìù Prep Files"
        TEMP="/tmp/meta.md"
        echo "" > "$TEMP"
        echo "> **Content Signature:** $SIGNATURE" >> "$TEMP"
        echo "> **Caller ID:** $CALLER_ID" >> "$TEMP"
        echo "> **Source SHA:** $HEAD_SHA" >> "$TEMP"
        echo "> **Data:** $(date -u)" >> "$TEMP"
        echo "" >> "$TEMP"
        cat "$REPORT" >> "$TEMP"
        mv "$TEMP" "$REPORT"

        TEMPLATE_SOURCE="$DEFAULT_TEMPLATE"
        if [[ -n "$CUSTOM_TEMPLATE" && -f "$CUSTOM_TEMPLATE" ]]; then
           TEMPLATE_SOURCE="$CUSTOM_TEMPLATE"
        fi
        echo "TEMPLATE_SOURCE: $TEMPLATE_SOURCE"

        export USER_BODY PR_NUM HEAD_REF CALLER_ID SIGNATURE
        PR_BODY_FILE="/tmp/pr_b_body.md"
        envsubst < "$TEMPLATE_SOURCE" > "$PR_BODY_FILE"

        echo "" >> "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"

        echo "pr_body_file=$PR_BODY_FILE" >> "$GITHUB_OUTPUT"
        echo "pr_body_file=$PR_BODY_FILE"
        echo "::endgroup::"

    - id: publish
      if: steps.analyze_pr_status.outputs.status_code == 'NOT_FOUND'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        HEAD_REF: ${{ github.head_ref }}
        PREFIX: ${{ inputs.report_branch_prefix }}
        REPORT: ${{ inputs.report_file }}
        TITLE: ${{ inputs.pr_title }}
        BODY_FILE: ${{ steps.prepare_files.outputs.pr_body_file }}
      run: |
        echo "::group::üöÄ Publishing"
        REPORT_BRANCH="${PREFIX}/${HEAD_REF}"
        git checkout "$HEAD_REF"
        git checkout -B "$REPORT_BRANCH"
        git add "$REPORT"
        git commit -m "docs: automated report [skip ci]"
        git push -f origin "$REPORT_BRANCH"
        
        if gh pr create --base "$HEAD_REF" --head "$REPORT_BRANCH" --title "$TITLE" --body-file "$BODY_FILE"; then
           echo "‚úÖ New PR created."
        else
           echo "‚ÑπÔ∏è PR creation skipped. Updating existing..."
        fi
        
        PR_URL=$(gh pr view "$REPORT_BRANCH" --json url -q .url)
        echo "PR_URL: $PR_URL"
        if ! gh pr edit "$PR_URL" --body-file "$BODY_FILE"; then
          echo "üî¥ Erro ao atualizar PR em $PR_URL com o arquivo $BODY_FILE" >&2
        fi
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "status=PUBLISHED" >> "$GITHUB_OUTPUT"
        
        echo "pr_url=$PR_URL"
        echo "status=PUBLISHED"
        echo "::endgroup::"

    # BLOCK 6: CONTROLLER
    - id: controller
      shell: bash
      if: always()
      env:
        S3: ${{ steps.publish.outputs.status }}
        URL: ${{ steps.publish.outputs.pr_url }}
        URL_EXIST: ${{ steps.analyze_pr_status.outputs.existing_url }}
      run: |
        if [ -n "$S3" ]; then FINAL="$S3"; else FINAL="SKIPPED"; fi
        if [ -n "$URL" ]; then FURL="$URL"; else FURL="$URL_EXIST"; fi
        echo "status=$FINAL" >> "$GITHUB_OUTPUT"
        echo "pr_url=$FURL" >> "$GITHUB_OUTPUT"
