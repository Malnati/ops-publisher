# Malnati/ops-publisher@3.0.0
name: "Ops Publisher"
description: "File publisher by new branch and Pull Request."
author: "Ricardo Malnati"

branding:
  icon: "git-pull-request"
  color: "blue"

inputs:
  token:
    description: "GitHub token."
    required: true
  pr_number:
    description: "Pull Request source number, if it will be used to find out which is the destination branch of the new PR."
    required: true
  attached_file_path:
    description: "File attached to the repository. (report.csv)"
    required: true
  branch_convention_prefix:
    required: false
    default: "ops/files"
  pr_title:
    required: false
    default: "üõ°Ô∏è Automated Pull Request"
  pr_template_path:
    required: true
    description: "File attached to the repository. (pr-template.md)"
  timeline_template_path:
    required: true
    description: "File attached to the repository. (timeline-template.md)"
  bot_name:
    description: "Name of the bot used in commits."
    required: false
    default: "git-pr-ops-bot"
  bot_email:
    required: false
    default: "git-pr-ops@users.noreply.github.com"
  errors:
    required: false
    default: ".github/workflows/errors.log"

runs:
  using: "composite"
  steps:
    - name: "üß∞ Setup error logging"
      uses: Malnati/ops-errors@v1.0.0
      with:
        errors: ${{ inputs.errors }}

    - id: step_validate_inputs
      name: "üîß Setup & Input Validation"
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        CALLER_ID: ${{ inputs.caller_id }}
        BRANCH_CONVENTION_PREFIX: ${{ inputs.branch_convention_prefix }}
        PR_TITLE: ${{ inputs.pr_title }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        PR_TEMPLATE_PATH: ${{ inputs.pr_template_path }}
        TIMELINE_TEMPLATE_PATH: ${{ inputs.timeline_template_path }}
        ERRORS_PATH: ${{ inputs.errors }}
      run: |
        echo "::group::üîß Setup & Input Validation"

        if [ -z "$TOKEN" ]; then
          echo "‚ùå [token] Mandatory and not informed. Without this token, Action cannot call the GitHub API (gh CLI, PR creation/editing and comments)."
          echo "   ‚ûú Set 'token' with 'secrets.GITHUB_TOKEN' or a PAT with read/write permissions in PRs."
          exit 1
        else
          echo "‚úÖ [token] Informed. Action will be able to create/update PRs and publish comments."
        fi

        if [ -z "$PR_NUMBER" ]; then
          echo "‚ùå [pr_number] Mandatory and not informed. Without this pr_number, Action cannot find out which is the destination branch of the new PR."
          echo "   ‚ûú Set 'pr_number' with 'N' or '#N' of the PR source."
          exit 1
        else
          echo "‚úÖ [pr_number] Informed. Action will dynamically find out which is the destination branch of the new PR."
        fi

        if [ -z "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] Path not informed. Action needs a file to attach to PR."
          echo "   ‚ûú Generate the report in the previous job and pass the path to 'attached_file_path' (e.g. 'reports/pmd-report.md')."
          exit 1
        elif [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå [attached_file_path] File '$ATTACHED_FILE_PATH' not found."
          echo "   ‚ûú Check the path entered in 'attached_file_path' and ensure that the file is created before this Action."
          exit 1
        else
          echo "‚úÖ [Attached_file_path] Found in '$ATTACHED_FILE_PATH'. It will be used as the basis of the published file."
        fi

        if [ -z "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå  [pr_template_path] Not informed."
          echo "   ‚ûú Define 'pr_template_path' with the path of a custom template to customize the PR body."
          exit 1
        elif [ ! -f "$PR_TEMPLATE_PATH" ]; then
          echo "‚ùå [pr_template_path] File '$PR_TEMPLATE_PATH' not found."
          echo "   ‚ûú Check the path entered in 'attached_file_path' and ensure that the file is created before this Action."
          exit 1
        else
          echo "‚úÖ [pr_template_path] Found in '$PR_TEMPLATE_PATH'. It will be used to display the description of the Pull Request."
        fi

        if [ -z "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå  [timeline_template_path] Not informed."
          echo "   ‚ûú Define 'timeline_template_path' with the path of a custom template to customize the timeline message in PR."
          exit 1
        elif [ ! -f "$TIMELINE_TEMPLATE_PATH" ]; then
          echo "‚ùå [timeline_template_path] File '$TIMELINE_TEMPLATE_PATH' not found."
          echo "   ‚ûú Check the path entered in 'timeline_template_path' and ensure that the file is created before this Action."
          exit 1
        else
          echo "‚úÖ [timeline_template_path] Found in '$TIMELINE_TEMPLATE_PATH'. It will be used to display the message on the Pull Request timeline."
        fi

        if [ -z "$ERRORS_PATH" ]; then
          echo "‚ÑπÔ∏è [errors] Not informed."
          echo "   ‚ûú Define 'errors' with the path of a custom log file to center the error outputs of this workflow."
        else
          echo "‚úÖ [erros] Erro de registro habilitado em '$ERRORS_PATH'."
        fi

        if [ -z "$BRANCH_CONVENTION_PREFIX" ]; then
          echo "‚ÑπÔ∏è [branch_convention_prefix] Not informed. Report branches will be created without a dedicated prefix, and may conflict with development branches."
          echo "   ‚ûú Set a prefix to isolate report branches: '<prefix>/<branch_origin>'."
        else
          echo "‚ÑπÔ∏è [branch_convention_prefix] Using prefix: '<prefix>/<sufixo_commit>'."
          echo "   ‚ûú The report branches will be created as '<prefix>/<suffix_commit>'."
        fi

        if [ -z "$PR_TITLE" ]; then
          echo "‚ÑπÔ∏è [pr_title] Not informed. The PR can be created without a clear title, making it difficult to read in the list of PRs."
          echo "   ‚ûú Set 'pr_title' with a descriptive title (e.g. 'üõ°Ô∏è Automated Pull Request')."
        else
          echo "‚ÑπÔ∏è [pr_title] Title set to: '$PR_TITLE'."
          echo "   ‚ûú This value will be used as a title of the report PRs."
        fi

        if [ -z "$BOT_EMAIL" ]; then
          echo "‚ÑπÔ∏è [bot_email] Not informed. Git will use the default environment email and this can break the author-based loop protection."
          echo "   ‚ûú Set 'bot_email' (ex.: 'git-pr-ops@users.noreply.github.com') for: "
          echo "      - Identify the bot's commits; "
          echo "      - Allow the anti-loop circuit to work properly."
        else
          echo "‚ÑπÔ∏è [bot_email] Using: '$BOT_EMAIL'."
          echo "   ‚ûú This email will be configured as the author of the commits and used in loop verification."
        fi

        echo "‚úÖ Input validation complete."
        echo "::endgroup::"

    - id: pr_info
      name: "üîç Obtain information from the source PR"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        PR_NUMBER: ${{ inputs.pr_number }}
      run: |
        set -euo pipefail

        if ! gh auth status >/dev/null 2>&1; then
          with_error_log "pr_info: gh auth login" bash -c 'gh auth login --with-token <<<"$GH_TOKEN" >/dev/null'
        fi

        PR_JSON="$(with_error_log "pr_info: gh pr view" gh pr view "$PR_NUMBER" --json url,title,headRefName,headRefOid,baseRefName,baseRefOid)"

        PR_URL=$(echo "$PR_JSON" | jq -r '.url')
        PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')

        DEST_BRANCH_NAME=$(echo "$PR_JSON" | jq -r '.baseRefName')
        DEST_BRANCH_SHA=$(echo "$PR_JSON" | jq -r '.baseRefOid')

        SOURCE_BRANCH_NAME=$(echo "$PR_JSON" | jq -r '.headRefName')
        SOURCE_BRANCH_SHA=$(echo "$PR_JSON" | jq -r '.headRefOid')

        echo "PR_URL=$PR_URL"
        echo "PR_TITLE=$PR_TITLE"
        echo "DEST_BRANCH_NAME=$DEST_BRANCH_NAME"
        echo "DEST_BRANCH_SHA=$DEST_BRANCH_SHA"
        echo "SOURCE_BRANCH_NAME=$SOURCE_BRANCH_NAME"
        echo "SOURCE_BRANCH_SHA=$SOURCE_BRANCH_SHA"

        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "pr_title=$PR_TITLE" >> "$GITHUB_OUTPUT"
        echo "dest_branch_name=$DEST_BRANCH_NAME" >> "$GITHUB_OUTPUT"
        echo "dest_branch_sha=$DEST_BRANCH_SHA" >> "$GITHUB_OUTPUT"
        echo "source_branch_name=$SOURCE_BRANCH_NAME" >> "$GITHUB_OUTPUT"
        echo "source_branch_sha=$SOURCE_BRANCH_SHA" >> "$GITHUB_OUTPUT"

    - name: "üîÅ Find derived PRs"
      id: derivated_prs_finder
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        SOURCE_BRANCH: ${{ steps.pr_info.outputs.source_branch_name }}
      run: |
        set -euo pipefail

        if ! gh auth status >/dev/null 2>&1; then
          with_error_log "derivated_prs_finder: gh auth login" bash -c 'gh auth login --with-token <<<"$GH_TOKEN" >/dev/null'
        fi

        if [ -z "$SOURCE_BRANCH" ]; then
          echo "‚ö† SOURCE_BRANCH vazio. Nada a fazer."
          exit 0
        fi

        PR_LIST="$(with_error_log "derivated_prs_finder: gh pr list" gh pr list --state open --base "$SOURCE_BRANCH" --json number,url,headRefName,baseRefName)"

        COUNT=$(echo "$PR_LIST" | jq 'length')

        echo "üîç PRs derivadas abertas com destino em '$SOURCE_BRANCH': total=$COUNT"

        echo "$PR_LIST" | jq -c '.[]' | while read -r pr; do
          NUM=$(echo "$pr" | jq -r '.number')
          URL=$(echo "$pr" | jq -r '.url')
          HEAD=$(echo "$pr" | jq -r '.headRefName')
          BASE=$(echo "$pr" | jq -r '.baseRefName')

          echo "- #$NUM $URL"
          echo "  head: $HEAD"
          echo "  base: $BASE"
        done

        echo "derived_count=$COUNT" >> "$GITHUB_OUTPUT"
        echo "derived_prs_json=$PR_LIST" >> "$GITHUB_OUTPUT"

    - id: branch_convention
      name: "ü™æ Branch Convention"
      shell: bash
      env:
        BRANCH_CONVENTION_PREFIX: ${{ inputs.branch_convention_prefix }}
      run: |
        set -euo pipefail
        echo "::group::ü™æ Define branch convention"

        if [ -z "${BRANCH_CONVENTION_PREFIX:-}" ]; then
          BRANCH_CONVENTION_PREFIX="ops/report/latest"
        fi

        git fetch --all --prune --quiet

        LATEST_SHA="$(git rev-parse HEAD)"
        CUSTOM_SUFFIX="${LATEST_SHA: -10}"

        BRANCH_CONVENTION="${BRANCH_CONVENTION_PREFIX}/${CUSTOM_SUFFIX}"

        echo "prefix: $BRANCH_CONVENTION_PREFIX"
        echo "latest_sha: $LATEST_SHA"
        echo "custom_suffix: $CUSTOM_SUFFIX"
        echo "branch_convention: $BRANCH_CONVENTION"

        echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    - id: commit_attached_file
      name: "üìù Commit File"
      shell: bash
      env:
        ATTACHED_FILE_PATH: ${{ inputs.attached_file_path }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
        BOT_EMAIL: ${{ inputs.bot_email }}
        BOT_NAME: ${{ inputs.bot_name }}
      run: |
        set -euo pipefail
        echo "::group::üìù Commit file"
        echo "branch_convention: $BRANCH_CONVENTION"
        echo "attached_file_path: $ATTACHED_FILE_PATH"

        if [ -z "${BRANCH_CONVENTION:-}" ]; then
          echo "‚ùå BRANCH_CONVENTION Empty. Check the branch_convention block."
          echo "::endgroup::"
          exit 1
        fi

        git fetch --all --prune --quiet

        if git show-ref --verify --quiet "refs/heads/$BRANCH_CONVENTION"; then
          echo "‚Ñπ Branch already exists locally: $BRANCH_CONVENTION"
          git checkout "$BRANCH_CONVENTION"
        else
          if git ls-remote --exit-code --heads origin "$BRANCH_CONVENTION" >/dev/null 2>&1; then
            echo "‚Ñπ Branch exists in the remote, creating local tracking: $BRANCH_CONVENTION"
            git checkout -q -b "$BRANCH_CONVENTION" "origin/$BRANCH_CONVENTION"
          else
            echo "üÜï Creating a new branch from the current HEAD: $BRANCH_CONVENTION"
            git checkout -q -b "$BRANCH_CONVENTION"
          fi
        fi

        if [ ! -f "$ATTACHED_FILE_PATH" ]; then
          echo "‚ùå Report file not found: $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 1
        fi

        git config user.email "$BOT_EMAIL"
        if [ -n "${BOT_NAME:-}" ]; then
          git config user.name "$BOT_NAME"
        fi

        git add "$ATTACHED_FILE_PATH"

        if git diff --cached --quiet; then
          echo "‚ö†Ô∏è No changes to commit to $ATTACHED_FILE_PATH"
          echo "::endgroup::"
          exit 0
        fi

        git commit -m "chore(attach): update attached file"
        git push origin "$BRANCH_CONVENTION"

        COMMIT_SHA="$(git rev-parse HEAD)"
        echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"
        echo "branch_convention=$BRANCH_CONVENTION" >> "$GITHUB_OUTPUT"
        echo "‚úÖ Attached file commit performed in $BRANCH_CONVENTION (commit $COMMIT_SHA)"
        echo "::endgroup::"

    - name: "üßæ Export basename"
      id: attached_base_file
      shell: bash
      run: |
        echo "attached_file_basename=$(basename '${{ inputs.attached_file_path }}')" >> "$GITHUB_OUTPUT"

    - name: "üìÑ Render PR template"
      id: render_pr
      uses: Malnati/templateer@v1.0.1
      env:
        ATTACHED_FILE_PATH: ${{ steps.attached_base_file.outputs.attached_file_basename }}
        PR_NUMBER: ${{ inputs.pr_number }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
      with:
        template: ${{ inputs.pr_template_path }}
        result: /tmp/hardcode-pr.md

    - id: publish_pr
      name: "üöÄ Publishing Pull Request"
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        BASE_BRANCH: ${{ steps.pr_info.outputs.source_branch_name }}
        HEAD_BRANCH: ${{ steps.commit_attached_file.outputs.branch_convention }}
        TITLE: ${{ inputs.pr_title }}
        PR_TEMPLATE_PATH: ${{ steps.render_pr.outputs.path }}
        HEAD_PREFIX: ops/files/
      run: |
        set -euo pipefail

        if ! gh auth status >/dev/null 2>&1; then
          with_error_log "publish_pr: gh auth login" bash -c 'gh auth login --with-token <<<"$GH_TOKEN" >/dev/null'
        fi

        EXISTING_URL="$(with_error_log "publish_pr: gh pr list (existing url)" gh pr list --state open --base "$BASE_BRANCH" --json url,headRefName --jq '([.[] | select(.headRefName | startswith(env.HEAD_PREFIX))][0].url) // ""')"

        if [ -n "${EXISTING_URL:-}" ]; then
          echo "PR_URL: $EXISTING_URL"
          echo "pr_url=$EXISTING_URL" >> "$GITHUB_OUTPUT"
          echo "pr_state=OPEN" >> "$GITHUB_OUTPUT"
        else
          with_error_log "publish_pr: gh pr create" gh pr create --base "$BASE_BRANCH" --head "$HEAD_BRANCH" --title "$TITLE" --body-file "$PR_TEMPLATE_PATH" >/dev/null

          PR_URL="$(with_error_log "publish_pr: gh pr view (url)" gh pr view "$HEAD_BRANCH" --json url --jq '.url')"

          echo "PR_URL: $PR_URL"
          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "pr_state=OPEN" >> "$GITHUB_OUTPUT"
        fi

    - name: "üìÑ Render timeline template"
      id: render_timeline
      uses: Malnati/templateer@v1.0.1
      env:
        ATTACHED_FILE_PATH: ${{ steps.attached_base_file.outputs.attached_file_basename }}
        PR_NUMBER: ${{ inputs.pr_number }}
        BRANCH_CONVENTION: ${{ steps.branch_convention.outputs.branch_convention }}
        PR_URL: ${{ steps.publish_pr.outputs.pr_url }}
      with:
        template: ${{ inputs.timeline_template_path }}
        result: /tmp/hardcode-timeline.md
          
    - id: timeline_notification
      name: "üîî Notify over PR Timeline"
      uses: Malnati/pr-comment@v8.0.2
      with:
        token: ${{ inputs.token }}
        pr_number: ${{ inputs.pr_number }}
        template_path: ${{ steps.render_timeline.outputs.path }}
